type Query {
  currentTime: Date
}

scalar Date

type Mutation {
  lnNoAmountInvoiceCreateOnBehalfOfRecipient(
    input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput!
  ): LnNoAmountInvoicePayload!
  captchaChallengeCreate: CaptchaChallengePayload!
  authCodeRequest(input: AuthCodeRequestInput!): AuthCodeRequestPayload!
}

type LnNoAmountInvoicePayload {
  errors: [UserError!]!
  invoice: LnNoAmountInvoice
}

type UserError {
  message: String!
  fields: [String!]!
}

type LnNoAmountInvoice {
  paymentRequest: LnInvoicePaymentRequest!
  paymentHash: LnInvoicePaymentHash!
  paymentSecret: LnInvoicePaymentSecret!
}

scalar LnInvoicePaymentRequest

scalar LnInvoicePaymentHash

scalar LnInvoicePaymentSecret

input LnNoAmountInvoiceCreateOnBehalfOfRecipientInput {
  recipient: Username!
  memo: Memo
}

scalar Username

scalar Memo

type CaptchaChallengePayload {
  errors: [UserError!]!
  result: CaptchaChallengeResult
}

type CaptchaChallengeResult {
  id: String!
  challengeCode: String!
  newCaptcha: Boolean!
  failbackMode: Boolean!
}

type AuthCodeRequestPayload {
  errors: [UserError!]!
  success: Boolean!
}

input AuthCodeRequestInput {
  phone: Phone!
  challengeCode: String!
  validationCode: String!
  secCode: String!
}

scalar Phone

type Subscription {
  lnInvoicePaymentStatus(
    input: LnInvoicePaymentStatusInput!
  ): LnInvoicePaymentStatusPayload!
}

type LnInvoicePaymentStatusPayload {
  errors: [UserError!]!
  status: InvoicePaymentStatus
}

enum InvoicePaymentStatus {
  PENDING
  PAID
}

input LnInvoicePaymentStatusInput {
  paymentRequest: LnInvoicePaymentRequest!
  lookupToken: String!
}
