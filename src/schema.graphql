type Transaction {
  id: ID!
  amount: Int!
  description: String!
  fee: Int
  created_at: Int! # TODO create a Date scalar
  # https://www.apollographql.com/docs/graphql-tools/scalars/
  hash: String
  usd: Float #TODO use Int and * 100
  sat: Int
  pending: Boolean
  type: String!
  feeUsd: Float # TODO: move to Int
  addresses: [String]
  username: String
}

type Price {
  id: ID!
  o: Float
}

type Earn {
  """
  the earn reward for the app to display their associated amount
  """
  id: ID!
  value: Int!
  completed: Boolean
}

type Wallet {
  id: ID
  currency: String # enum?
  balance: Int
  transactions: [Transaction]
  csv: String
}

type Balance {
  id: ID
  balance: Int
}

type Wallet2 {
  balances: [Balance]
  csv: String
  transactions: [Transaction]
}

type Contact {
  id: ID #username
  name: String #name can be set by the user
  transactionsCount: Int # number of transactions
}

type Invoice {
  addInvoice(value: Int, memo: String): String
  updatePendingInvoice(hash: String!): Boolean
  payInvoice(invoice: String!, amount: Int, memo: String): String #FIXME: use a more precise type
  payKeysendUsername(amount: Int!, destination: String!, username: String!, memo: String): String
  getFee(destination: String, amount: Int, invoice: String, memo: String): Int # sats
}

type OnChain {
  getNewAddress: String
  pay(address: String!, amount: Int!, memo: String): Success
  getFee(address: String!, amount: Int): Int # sats
}

type LastOnChainAddress {
  id: ID
}

type OnchainTransaction {
  tx: String
}

type User {
  id: ID
  username: String
  level: Int!
  phone: String
  contacts: [Contact]
  language: String
  title: String
  created_at: String
  coordinate: Coordinate
  status: AccountStatus
}

type Success {
  success: Boolean
}

type Token {
  token: String
}

type BuildParameter {
  id: ID
  commitHash: String
  buildTime: String
  helmRevision: Int
  minBuildNumberAndroid: Int
  minBuildNumberIos: Int
  lastBuildNumberAndroid: Int
  lastBuildNumberIos: Int
}

type NodeStats {
  id: ID # nodePublicKey
  peersCount: Int
  channelsCount: Int
}

type Coordinate {
  latitude: Float
  longitude: Float
}

type Marker {
  id: ID
  title: String
  coordinate: Coordinate
  username: String
}

type Query {
  prices(length: Int): [Price]
  wallet: [Wallet]
  wallet2: [Wallet2]
  earnList: [Earn]
  me: User
  maps: [Marker]
  buildParameters(appVersion: String @deprecated, buildVersion: String @deprecated, os: String @deprecated): BuildParameter
  nodeStats: NodeStats
  getLastOnChainAddress: LastOnChainAddress
  usernameExists(username: String!): Boolean
  getUserDetails(uid: ID!): User
  noauthUpdatePendingInvoice(username: String!, hash: String!): Boolean
  getUid(username: String, phone: String): ID
  getLevels: [Int]
  getLimits: Limits
  getWalletFees: WalletFees
}

type WalletFees {
  deposit: Float
}

type Limits {
  oldEnoughForWithdrawal: Int
  withdrawal: Int
  onUs: Int
}

type UpdateUser {
  setLanguage(language: String): Boolean @deprecated
  setUsername(username: String!): Boolean @deprecated
  updateLanguage(language: String!): User
  updateUsername(username: String!): User
}

type UpdateContact {
  setName(username: String, name: String): Boolean
}

enum AccountStatus {
  active
  locked
}

type Mutation {
  requestPhoneCode(phone: String): Success
  login(phone: String, code: Int, currency: String): Token
    @deprecated(reason: "currency is no longer user. to be remove after mobile update")
  noauthAddInvoice(username: String!, value: Int): String
  onchain: OnChain
  invoice: Invoice
  earnCompleted(ids: [ID]): [Earn]
  updateUser: UpdateUser
  updateContact: UpdateContact
  deleteUser: Boolean # TODO
  addDeviceToken(deviceToken: String): Success # to refactor with User?
  testMessage: Success # FIXME remove test
  addToMap(username: String!, title: String!, latitude: Float!, longitude: Float!): Boolean
  setAccountStatus(uid: ID!, status: AccountStatus!): User
  setLevel(uid: ID!, level: Int!): User
}
