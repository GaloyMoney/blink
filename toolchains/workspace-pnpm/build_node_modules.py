#!/usr/bin/env python3
"""
Installs package node modules via Pnpm and Turbo.
"""
import argparse
import os
import shutil
import subprocess
import sys
import tempfile
import time

def create_symlink(src, dest):
    """Create a symlink from src to dest, handling cases where the destination might already exist."""
    # Ensure the parent directory exists
    parent_dir = os.path.dirname(dest)
    os.makedirs(parent_dir, exist_ok=True)

    # Handle existing destination
    if os.path.exists(dest) or os.path.islink(dest):
        print(f"Removing existing path: {dest}", file=sys.stderr)
        try:
            if os.path.islink(dest):
                os.unlink(dest)
            elif os.path.isdir(dest):
                shutil.rmtree(dest)
            else:
                os.remove(dest)
        except Exception as e:
            print(f"Warning: Could not remove existing destination: {e}", file=sys.stderr)
            return False

    # Create the symlink
    try:
        print(f"Creating symlink: {src} -> {dest}", file=sys.stderr)
        os.symlink(src, dest, target_is_directory=True)
        return True
    except Exception as e:
        print(f"Error creating symlink: {e}", file=sys.stderr)
        return False

def run_command(cmd, cwd=None, timeout=600):
    """Run a command with improved error handling and timeout."""
    print(f"Running command: {' '.join(cmd)}", file=sys.stderr)
    try:
        process = subprocess.Popen(
            cmd,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
        )

        # Poll the process with timeout
        start_time = time.time()
        while process.poll() is None:
            if time.time() - start_time > timeout:
                process.terminate()
                time.sleep(1)
                if process.poll() is None:
                    process.kill()
                print(f"Error: Command timed out after {timeout} seconds", file=sys.stderr)
                return 1
            time.sleep(1)  # Check every second

        # Get output and error
        stdout, stderr = process.communicate()
        exit_code = process.returncode

        # Print output on error
        if exit_code != 0:
            print(f"Command failed with exit code {exit_code}", file=sys.stderr)
            print("STDOUT:", file=sys.stderr)
            print(stdout, file=sys.stderr)
            print("STDERR:", file=sys.stderr)
            print(stderr, file=sys.stderr)

        return exit_code
    except Exception as e:
        print(f"Error running command: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--package-dir",
        help="Path to the workspace member package",
    )
    parser.add_argument(
        "--turbo-bin",
        required=True,
        help="Path to `turbo` binary",
    )
    parser.add_argument(
        "--prod-only",
        action="store_true",
        help="Only install production node modules",
    )
    parser.add_argument(
        "out_path",
        help="Path to output tree of `node_modules`",
    )

    args = parser.parse_args()

    with tempfile.TemporaryDirectory() as tempdir:
        # `turbo prune` is pretty keen on the `--out-dir` being a sub-directory
        # of the workspace root, so we're going to create a symlink under the
        # `buck-out` directory which links back to the `tempdir`, only for the
        # `turbo prune` call.
        turbo_out_path = os.path.join(os.path.dirname(args.out_path), "tmp")

        # Create symlink with proper error handling
        if not create_symlink(tempdir, turbo_out_path):
            print("Failed to create temporary symlink for turbo", file=sys.stderr)
            sys.exit(1)

        turbo_cmd = [
            args.turbo_bin,
            "prune",
            "--out-dir",
            turbo_out_path,
            "--docker",
        ]

        scope = os.path.basename(args.package_dir)

        turbo_cmd.append("--scope")
        turbo_cmd.append(scope)

        # Run turbo command with better error handling
        turbo_exit_code = run_command(turbo_cmd)

        # Clean up the temporary symlink
        try:
            if os.path.exists(turbo_out_path) or os.path.islink(turbo_out_path):
                os.unlink(turbo_out_path)
        except Exception as e:
            print(f"Warning: Could not remove temporary symlink: {e}", file=sys.stderr)

        if turbo_exit_code != 0:
            print("Failed to successfully run turbo command", file=sys.stderr)
            sys.exit(1)

        # Prepare output files
        try:
            # Ensure both source and destination directories exist
            json_dir = os.path.join(tempdir, "json")
            if not os.path.exists(json_dir):
                print(f"Warning: Expected directory not found: {json_dir}", file=sys.stderr)
                os.makedirs(json_dir, exist_ok=True)

            # Copy lock file
            lock_src = os.path.join(tempdir, "pnpm-lock.yaml")
            lock_dest = os.path.join(json_dir, "pnpm-lock.yaml")
            if os.path.exists(lock_src):
                shutil.copy(lock_src, lock_dest)
            else:
                print(f"Warning: pnpm-lock.yaml not found at {lock_src}", file=sys.stderr)

            # Ensure the output directory's parent exists
            os.makedirs(os.path.dirname(args.out_path), exist_ok=True)

            # Remove destination if it exists
            if os.path.exists(args.out_path):
                if os.path.islink(args.out_path):
                    os.unlink(args.out_path)
                else:
                    shutil.rmtree(args.out_path)

            # Copy the json directory to the output path
            shutil.copytree(
                json_dir,
                args.out_path,
                symlinks=True,
            )
        except Exception as e:
            print(f"Error during file operations: {e}", file=sys.stderr)
            sys.exit(1)

    # Run pnpm install
    pnpm_cmd = ["pnpm", "install", "--frozen-lockfile"]
    if args.prod_only:
        pnpm_cmd.append("--prod")

    pnpm_exit_code = run_command(pnpm_cmd, cwd=args.out_path)

    sys.exit(pnpm_exit_code)
