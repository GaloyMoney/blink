import crypto from "crypto"

import { ApolloClient, NormalizedCacheObject } from "@apollo/client/core"
import { toSats } from "@domain/bitcoin"

import { gql } from "apollo-server-core"

import {
  createApolloClient,
  defaultStateConfig,
  defaultTestClientConfig,
  initializeTestingState,
  killServer,
  startServer,
} from "test/e2e/helpers"
import {
  clearAccountLocks,
  clearLimiters,
  fundWalletIdFromLightning,
  getAccountByPhone,
  getDefaultWalletIdByPhone,
  getPhoneAndCodeFromPhone,
} from "test/helpers"
import { loginFromPhone } from "test/e2e/helpers/account-creation"
import {
  LnInvoiceCreateOnBehalfOfRecipientDocument,
  LnInvoiceCreateOnBehalfOfRecipientMutation,
  LnNoAmountInvoiceCreateOnBehalfOfRecipientDocument,
  LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation,
  UserLoginDocument,
  UserLoginMutation,
  UserUpdateUsernameMutation,
  UserUpdateUsernameDocument,
} from "test/e2e/generated"

let apolloClient: ApolloClient<NormalizedCacheObject>,
  disposeClient: () => void = () => null,
  receivingWalletId: WalletId,
  serverMainPid: PID,
  serverWsPid: PID
const receivingUsername = "user15" as Username
const receivingUserRef = "G"
const sendingUserRef = "D"

const { phone, code } = getPhoneAndCodeFromPhone(sendingUserRef)
const { phone: phoneRecipient, code: codeRecipient } =
  getPhoneAndCodeFromPhone(receivingUserRef)

beforeAll(async () => {
  gql`
    mutation userUpdateUsername($input: UserUpdateUsernameInput!) {
      userUpdateUsername(input: $input) {
        errors {
          __typename
          message
        }
        user {
          __typename
          id
          username
        }
      }
    }
  `

  await initializeTestingState(defaultStateConfig())
  serverMainPid = await startServer("start-main-ci")
  serverWsPid = await startServer("start-ws-ci")

  // Ensure accounts are created and still exist
  await loginFromPhone({ phone })
  await getAccountByPhone(receivingUserRef)
  await getAccountByPhone(sendingUserRef)

  // Update username
  const { apolloClient: client } = await loginFromPhone({
    phone: phoneRecipient,
  })
  await client.mutate<UserUpdateUsernameMutation>({
    mutation: UserUpdateUsernameDocument,
    variables: { input: { username: receivingUsername } },
  })

  const sendingWalletId = await getDefaultWalletIdByPhone(sendingUserRef)
  await fundWalletIdFromLightning({ walletId: sendingWalletId, amount: toSats(50_000) })
  receivingWalletId = await getDefaultWalletIdByPhone(receivingUserRef)
  ;({ apolloClient, disposeClient } = createApolloClient(defaultTestClientConfig()))
  const input = { phone, code }
  const result = await apolloClient.mutate<UserLoginMutation>({
    mutation: UserLoginDocument,
    variables: { input },
  })
  // Create a new authenticated client
  disposeClient()
  const authToken = result?.data?.userLogin?.authToken as AuthToken
  if (!authToken) {
    throw new Error("No auth token returned")
  }
  ;({ apolloClient, disposeClient } = createApolloClient(
    defaultTestClientConfig(authToken),
  ))
})

beforeEach(async () => {
  await clearLimiters()
  await clearAccountLocks()
})

afterAll(async () => {
  disposeClient()
  await killServer(serverMainPid)
  await killServer(serverWsPid)
})

describe("galoy-pay", () => {
  describe("lnInvoiceCreateOnBehalfOfRecipient", () => {
    gql`
      mutation lnInvoiceCreateOnBehalfOfRecipient(
        $walletId: WalletId!
        $amount: SatAmount!
        $descriptionHash: Hex32Bytes!
      ) {
        mutationData: lnInvoiceCreateOnBehalfOfRecipient(
          input: {
            recipientWalletId: $walletId
            amount: $amount
            descriptionHash: $descriptionHash
          }
        ) {
          errors {
            message
          }
          invoice {
            paymentRequest
            paymentHash
            paymentSecret
            satoshis
          }
        }
      }
    `

    it("creates an invoice with valid inputs", async () => {
      const metadata = JSON.stringify([["text/plain", `Payment to ${receivingUsername}`]])
      const descriptionHash = crypto.createHash("sha256").update(metadata).digest("hex")
      const input = {
        walletId: receivingWalletId,
        amount: 1000,
        descriptionHash,
      }

      const result =
        await apolloClient.mutate<LnInvoiceCreateOnBehalfOfRecipientMutation>({
          mutation: LnInvoiceCreateOnBehalfOfRecipientDocument,
          variables: input,
        })

      const data = result?.data?.mutationData
      if (!data) throw new Error("no data returned from mutation")

      const { invoice, errors } = data

      expect(errors).toHaveLength(0)
      expect(invoice).toHaveProperty("paymentRequest")
      expect(invoice?.paymentRequest.startsWith("lnbc")).toBeTruthy()
      expect(invoice).toHaveProperty("paymentHash")
      expect(invoice).toHaveProperty("paymentSecret")
      expect(invoice?.satoshis).toBeGreaterThan(0)
    })

    it("fails to create an invoice for a nonexistent walletId", async () => {
      const metadata = JSON.stringify([["text/plain", `Payment to ${receivingUsername}`]])
      const descriptionHash = crypto.createHash("sha256").update(metadata).digest("hex")
      const input = {
        walletId: "wallet-id-does-not-exist",
        amount: 1000,
        descriptionHash,
      }

      const result =
        await apolloClient.mutate<LnInvoiceCreateOnBehalfOfRecipientMutation>({
          mutation: LnInvoiceCreateOnBehalfOfRecipientDocument,
          variables: input,
        })

      const data = result?.data?.mutationData
      if (!data) throw new Error("no data returned from mutation")

      const { invoice, errors } = data

      expect(invoice).toBeNull()
      expect(errors.length).toBeGreaterThan(0)
    })

    it("returns an error with a negative amount", async () => {
      const metadata = JSON.stringify([["text/plain", `Payment to ${receivingUsername}`]])
      const descriptionHash = crypto.createHash("sha256").update(metadata).digest("hex")
      const input = {
        walletId: receivingWalletId,
        amount: -1,
        descriptionHash,
      }

      const result =
        await apolloClient.mutate<LnInvoiceCreateOnBehalfOfRecipientMutation>({
          mutation: LnInvoiceCreateOnBehalfOfRecipientDocument,
          variables: input,
        })

      const data = result?.data?.mutationData
      if (!data) throw new Error("no data returned from mutation")

      const { invoice, errors } = data

      expect(errors.length).toBeGreaterThan(0)
      expect(invoice).toBe(null)
    })

    it("returns an error with a zero amount", async () => {
      const metadata = JSON.stringify([["text/plain", `Payment to ${receivingUsername}`]])
      const descriptionHash = crypto.createHash("sha256").update(metadata).digest("hex")
      const input = {
        walletId: receivingWalletId,
        amount: 0,
        descriptionHash,
      }

      const result =
        await apolloClient.mutate<LnInvoiceCreateOnBehalfOfRecipientMutation>({
          mutation: LnInvoiceCreateOnBehalfOfRecipientDocument,
          variables: input,
        })

      const data = result?.data?.mutationData
      if (!data) throw new Error("no data returned from mutation")

      const { invoice, errors } = data

      expect(errors.length).toBeGreaterThan(0)
      expect(invoice).toBe(null)
    })
  })

  describe("lnNoAmountInvoiceCreateOnBehalfOfRecipient", () => {
    gql`
      mutation lnNoAmountInvoiceCreateOnBehalfOfRecipient($walletId: WalletId!) {
        mutationData: lnNoAmountInvoiceCreateOnBehalfOfRecipient(
          input: { recipientWalletId: $walletId }
        ) {
          errors {
            message
          }
          invoice {
            paymentRequest
          }
        }
      }
    `
    it("returns a valid lightning invoice", async () => {
      const input = { walletId: receivingWalletId }

      const result =
        await apolloClient.mutate<LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation>({
          mutation: LnNoAmountInvoiceCreateOnBehalfOfRecipientDocument,
          variables: input,
        })
      const mutationData = result?.data?.mutationData
      if (!mutationData) throw new Error("no data returned from mutation")
      const { invoice, errors } = mutationData

      expect(errors).toHaveLength(0)
      expect(invoice).toHaveProperty("paymentRequest")
      expect(invoice?.paymentRequest.startsWith("lnbc")).toBeTruthy()
    })

    it("returns an error with an invalid walletId", async () => {
      const input = { walletId: "wallet-id-does-not-exist" }

      const result =
        await apolloClient.mutate<LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation>({
          mutation: LnNoAmountInvoiceCreateOnBehalfOfRecipientDocument,
          variables: input,
        })
      const mutationData = result?.data?.mutationData
      if (!mutationData) throw new Error("no data returned from mutation")
      const { invoice, errors } = mutationData

      expect(invoice).toBeNull()
      expect(errors.length).toBeGreaterThan(0)
    })
  })
})
