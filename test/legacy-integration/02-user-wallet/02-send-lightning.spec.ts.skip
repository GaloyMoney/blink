import { Payments } from "@app"
import * as PaymentsHelpers from "@app/payments/helpers"

import { AccountLimitsChecker } from "@domain/accounts"
import { toSats } from "@domain/bitcoin"
import { toCents } from "@domain/fiat"
import { WalletCurrency } from "@domain/shared"

import { LndService } from "@services/lnd"

import { setUsername } from "@app/accounts"

import {
  bitcoindClient,
  checkIsBalanced,
  createInvoice,
  createUserAndWalletFromPhone,
  fundWalletIdFromOnchain,
  getAccountByPhone,
  getDefaultWalletIdByPhone,
  getUsdWalletIdByPhone,
  lnd1,
  lndOutside1,
  randomPhone,
} from "test/helpers"

jest.mock("@config", () => {
  return {
    ...jest.requireActual("@config"),
    getAccountLimits: jest.fn().mockReturnValue({
      intraLedgerLimit: 100_000 as UsdCents,
      withdrawalLimit: 100_000 as UsdCents,
      tradeIntraAccountLimit: 100_000 as UsdCents,
    }),
  }
})

const lndService = LndService()
const lndServiceCallCount: { [key: string]: number } = {}
if (lndService instanceof Error) throw lndService
for (const key of Object.keys(lndService)) {
  lndServiceCallCount[key] = 0
}

jest.mock("@services/lnd", () => {
  const module = jest.requireActual("@services/lnd")
  const { LndService } = module

  const LndServiceWithCounts = () => {
    const lndService = LndService()
    if (lndService instanceof Error) return lndService

    const newLndService = {} as ILightningService
    for (const key of Object.keys(lndService)) {
      const fn = lndService[key]
      newLndService[key] = (args) => {
        lndServiceCallCount[key]++
        return fn(args)
      }
    }
    return newLndService
  }

  return {
    ...module,
    LndService: LndServiceWithCounts,
  }
})

const phoneA = randomPhone()
const phoneB = randomPhone()
const phoneC = randomPhone()
const phoneH = randomPhone()

let accountA: Account
let accountB: Account
let accountC: Account

let walletIdA: WalletId
let walletIdB: WalletId
let walletIdC: WalletId
let walletIdUsdB: WalletId

let usernameA: Username
let usernameB: Username
let usernameC: Username

beforeAll(async () => {
  await bitcoindClient.loadWallet({ filename: "outside" })

  await createUserAndWalletFromPhone(phoneA)
  await createUserAndWalletFromPhone(phoneB)
  await createUserAndWalletFromPhone(phoneC)
  await createUserAndWalletFromPhone(phoneH)

  accountA = await getAccountByPhone(phoneA)
  accountB = await getAccountByPhone(phoneB)
  accountC = await getAccountByPhone(phoneC)

  walletIdA = await getDefaultWalletIdByPhone(phoneA)
  walletIdB = await getDefaultWalletIdByPhone(phoneB)
  walletIdUsdB = await getUsdWalletIdByPhone(phoneB)
  walletIdC = await getDefaultWalletIdByPhone(phoneC)

  await fundWalletIdFromOnchain({
    walletId: walletIdA,
    amountInBitcoin: 0.02,
    lnd: lnd1,
  })
  await fundWalletIdFromOnchain({
    walletId: walletIdB,
    amountInBitcoin: 0.02,
    lnd: lnd1,
  })
  await fundWalletIdFromOnchain({
    walletId: walletIdUsdB,
    amountInBitcoin: 0.02,
    lnd: lnd1,
  })

  usernameA = "sendLighningUserA" as Username
  usernameB = "sendLighningUserB" as Username
  usernameC = "sendLighningUserC" as Username

  await setUsername({ username: usernameA, id: accountA.id })
  await setUsername({ username: usernameB, id: accountB.id })
  await setUsername({ username: usernameC, id: accountC.id })
})

afterEach(async () => {
  await checkIsBalanced()
})

afterAll(async () => {
  jest.restoreAllMocks()
  await bitcoindClient.unloadWallet({ walletName: "outside" })
})

describe("UserWalletLimit - handles 1 sat send with high btc outgoing volume", () => {
  const usdLimit = toCents(100_000)

  const accountLimits = {
    intraLedgerLimit: usdLimit,
    withdrawalLimit: usdLimit,
    tradeIntraAccountLimit: usdLimit,
  }

  const walletVolumes = [
    {
      outgoingBaseAmount: {
        amount: BigInt(usdLimit),
        currency: WalletCurrency.Btc,
      },
      incomingBaseAmount: { amount: 0n, currency: WalletCurrency.Btc },
    },
    {
      outgoingBaseAmount: { amount: 0n, currency: WalletCurrency.Usd },
      incomingBaseAmount: { amount: 0n, currency: WalletCurrency.Usd },
    },
  ]

  const mockedCheckWithdrawalLimits = ({
    amount,
    priceRatio,
  }: {
    amount: UsdPaymentAmount
    priceRatio: WalletPriceRatio
  }) => {
    return AccountLimitsChecker({
      accountLimits,
      priceRatio,
    }).checkWithdrawal({
      amount,
      walletVolumes,
    })
  }

  const mockedCheckIntraledgerLimits = ({
    amount,
    priceRatio,
  }: {
    amount: UsdPaymentAmount
    priceRatio: WalletPriceRatio
  }) => {
    return AccountLimitsChecker({
      accountLimits,
      priceRatio,
    }).checkIntraledger({
      amount,
      walletVolumes,
    })
  }

  it("estimate fee for zero amount invoice with 1 sat amount", async () => {
    jest
      .spyOn(PaymentsHelpers, "checkWithdrawalLimits")
      .mockImplementationOnce(mockedCheckWithdrawalLimits)
      .mockImplementationOnce(mockedCheckWithdrawalLimits)

    const senderWalletId = walletIdB
    const { request } = await createInvoice({ lnd: lndOutside1 })

    // Estimate fee with 2,000 sats
    const { error } = await Payments.getNoAmountLightningFeeEstimationForBtcWallet({
      walletId: senderWalletId,
      uncheckedPaymentRequest: request,
      amount: toSats(2_000),
    })
    expect(error).not.toBeInstanceOf(Error)

    // Estimate fee with 1 sat
    // This tests that a suitable WalletPriceRatio is passed into limits checker
    const { error: error1Sat } =
      await Payments.getNoAmountLightningFeeEstimationForBtcWallet({
        walletId: senderWalletId,
        uncheckedPaymentRequest: request,
        amount: toSats(1),
      })
    expect(error1Sat).not.toBeInstanceOf(Error)
  })

  it("pay zero amount invoice with 1 sat amount", async () => {
    jest
      .spyOn(PaymentsHelpers, "checkWithdrawalLimits")
      .mockImplementationOnce(mockedCheckWithdrawalLimits)

    const senderWalletId = walletIdB
    const senderAccount = accountB
    const { request } = await createInvoice({ lnd: lndOutside1 })

    const paid = await Payments.payNoAmountInvoiceByWalletIdForBtcWallet({
      senderWalletId,
      senderAccount,
      uncheckedPaymentRequest: request,
      amount: toSats(1),
      memo: "",
    })
    expect(paid).not.toBeInstanceOf(Error)
  })

  it("pay other Galoy user with 1 sat amount", async () => {
    jest
      .spyOn(PaymentsHelpers, "checkIntraledgerLimits")
      .mockImplementationOnce(mockedCheckIntraledgerLimits)

    const senderWalletId = walletIdB
    const senderAccount = accountB
    const paidIntraledger = Payments.intraledgerPaymentSendWalletIdForBtcWallet({
      senderWalletId,
      senderAccount,
      recipientWalletId: walletIdC,
      amount: toSats(1),
      memo: "",
    })
    expect(paidIntraledger).not.toBeInstanceOf(Error)
  })
})
