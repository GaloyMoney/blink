import { Payments } from "@app"
import * as PaymentsHelpers from "@app/payments/helpers"

import { AccountLimitsChecker } from "@domain/accounts"
import { toSats } from "@domain/bitcoin"
import { toCents } from "@domain/fiat"
import { InvalidFeeProbeStateError, PaymentSendStatus } from "@domain/bitcoin/lightning"
import { WalletCurrency } from "@domain/shared"

import { LndService } from "@services/lnd"
import { WalletsRepository } from "@services/mongoose"

import { setUsername } from "@app/accounts"

import {
  bitcoindClient,
  checkIsBalanced,
  createInvoice,
  createUserAndWalletFromPhone,
  fundWalletIdFromOnchain,
  getAccountByPhone,
  getBalanceHelper,
  getDefaultWalletIdByPhone,
  getTransactionsForWalletId,
  getUsdWalletIdByPhone,
  lnd1,
  lndOutside1,
  randomPhone,
} from "test/helpers"

jest.mock("@config", () => {
  return {
    ...jest.requireActual("@config"),
    getAccountLimits: jest.fn().mockReturnValue({
      intraLedgerLimit: 100_000 as UsdCents,
      withdrawalLimit: 100_000 as UsdCents,
      tradeIntraAccountLimit: 100_000 as UsdCents,
    }),
  }
})

const lndService = LndService()
const lndServiceCallCount: { [key: string]: number } = {}
if (lndService instanceof Error) throw lndService
for (const key of Object.keys(lndService)) {
  lndServiceCallCount[key] = 0
}

jest.mock("@services/lnd", () => {
  const module = jest.requireActual("@services/lnd")
  const { LndService } = module

  const LndServiceWithCounts = () => {
    const lndService = LndService()
    if (lndService instanceof Error) return lndService

    const newLndService = {} as ILightningService
    for (const key of Object.keys(lndService)) {
      const fn = lndService[key]
      newLndService[key] = (args) => {
        lndServiceCallCount[key]++
        return fn(args)
      }
    }
    return newLndService
  }

  return {
    ...module,
    LndService: LndServiceWithCounts,
  }
})

let initBalanceB: Satoshis
const amountInvoice = toSats(1000)

const phoneA = randomPhone()
const phoneB = randomPhone()
const phoneC = randomPhone()
const phoneH = randomPhone()

let accountA: Account
let accountB: Account
let accountC: Account
let accountH: Account

let walletIdA: WalletId
let walletIdB: WalletId
let walletIdC: WalletId
let walletIdH: WalletId
let walletIdUsdB: WalletId

let usernameA: Username
let usernameB: Username
let usernameC: Username

beforeAll(async () => {
  await bitcoindClient.loadWallet({ filename: "outside" })

  await createUserAndWalletFromPhone(phoneA)
  await createUserAndWalletFromPhone(phoneB)
  await createUserAndWalletFromPhone(phoneC)
  await createUserAndWalletFromPhone(phoneH)

  accountA = await getAccountByPhone(phoneA)
  accountB = await getAccountByPhone(phoneB)
  accountC = await getAccountByPhone(phoneC)
  accountH = await getAccountByPhone(phoneH)

  walletIdA = await getDefaultWalletIdByPhone(phoneA)
  walletIdB = await getDefaultWalletIdByPhone(phoneB)
  walletIdUsdB = await getUsdWalletIdByPhone(phoneB)
  walletIdC = await getDefaultWalletIdByPhone(phoneC)
  walletIdH = await getDefaultWalletIdByPhone(phoneH)

  await fundWalletIdFromOnchain({
    walletId: walletIdA,
    amountInBitcoin: 0.02,
    lnd: lnd1,
  })
  await fundWalletIdFromOnchain({
    walletId: walletIdB,
    amountInBitcoin: 0.02,
    lnd: lnd1,
  })
  await fundWalletIdFromOnchain({
    walletId: walletIdUsdB,
    amountInBitcoin: 0.02,
    lnd: lnd1,
  })

  usernameA = "sendLighningUserA" as Username
  usernameB = "sendLighningUserB" as Username
  usernameC = "sendLighningUserC" as Username

  await setUsername({ username: usernameA, id: accountA.id })
  await setUsername({ username: usernameB, id: accountB.id })
  await setUsername({ username: usernameC, id: accountC.id })
})

beforeEach(async () => {
  initBalanceB = toSats(await getBalanceHelper(walletIdB))
})

afterEach(async () => {
  await checkIsBalanced()
})

afterAll(async () => {
  jest.restoreAllMocks()
  await bitcoindClient.unloadWallet({ walletName: "outside" })
})

describe("UserWallet - Lightning Pay", () => {
  it("does not filter spam message for external send", async () => {
    const amount = toSats(1)
    const memoSpamBelowThreshold = "Memo BELOW spam threshold"
    const memoOnInvoice = `${memoSpamBelowThreshold} -- from payment request`
    const memoFromUser = `${memoSpamBelowThreshold} -- from user`

    const { request } = await createInvoice({
      lnd: lndOutside1,
      description: memoOnInvoice,
    })

    // Test probe + payment is successful
    const { result: fee, error } =
      await Payments.getNoAmountLightningFeeEstimationForBtcWallet({
        walletId: walletIdB,
        uncheckedPaymentRequest: request,
        amount,
      })
    if (error instanceof Error) throw error
    expect(fee).not.toBeNull()

    const paymentResult = await Payments.payNoAmountInvoiceByWalletIdForBtcWallet({
      uncheckedPaymentRequest: request,
      memo: memoFromUser,
      amount,
      senderWalletId: walletIdB,
      senderAccount: accountB,
    })
    if (paymentResult instanceof Error) throw paymentResult
    expect(paymentResult).toBe(PaymentSendStatus.Success)

    // Check memo on txns
    const txResult = await getTransactionsForWalletId(walletIdB)
    if (txResult.error instanceof Error || txResult.result === null) {
      throw txResult.error
    }
    const txns = txResult.result.slice
    expect(txns.length).toBeGreaterThan(0)
    const txn = txns[0]
    expect(txn.memo).toBe(memoFromUser)
  })

  it("sends balance amount accounting for fee", async () => {
    const res = await Payments.intraledgerPaymentSendWalletIdForBtcWallet({
      recipientWalletId: walletIdH,
      memo: "",
      amount: toSats(1000),
      senderWalletId: walletIdB,
      senderAccount: accountB,
    })
    expect(res).not.toBeInstanceOf(Error)
    if (res instanceof Error) return res

    const balanceBefore = await getBalanceHelper(walletIdH)
    const { request } = await createInvoice({ lnd: lndOutside1, tokens: balanceBefore })

    const { result: fee, error } = await Payments.getLightningFeeEstimationForBtcWallet({
      walletId: walletIdH,
      uncheckedPaymentRequest: request,
    })
    if (error instanceof Error) throw error
    expect(fee).not.toBeNull()
    if (fee === null) throw new InvalidFeeProbeStateError()
    expect(fee.amount).toBe(0n)

    const paymentResult = await Payments.payInvoiceByWalletId({
      uncheckedPaymentRequest: request,
      memo: null,
      senderWalletId: walletIdH,
      senderAccount: accountH,
    })
    if (paymentResult instanceof Error) return paymentResult
    expect(paymentResult).not.toBeInstanceOf(Error)
    expect(paymentResult).toStrictEqual(PaymentSendStatus.Success)

    const balanceAfter = await getBalanceHelper(walletIdH)
    expect(balanceAfter).toBe(0)
  })

  const functionToTests = [
    {
      name: "getFeeAndPay",
      fn: function fn({ walletId, account }: { walletId: WalletId; account: Account }) {
        return async (input): Promise<PaymentSendStatus | ApplicationError> => {
          const wallet = await WalletsRepository().findById(walletId)
          if (wallet instanceof Error) throw wallet

          const getLightningFeeFn =
            wallet.currency === WalletCurrency.Btc
              ? Payments.getLightningFeeEstimationForBtcWallet
              : Payments.getLightningFeeEstimationForUsdWallet

          const { result: feeFromProbe, error } = await getLightningFeeFn({
            walletId: walletId,
            uncheckedPaymentRequest: input.invoice,
          })
          if (error instanceof Error) throw error
          expect(feeFromProbe).not.toBeNull()
          if (feeFromProbe === null) throw new InvalidFeeProbeStateError()

          const paymentResult = await Payments.payInvoiceByWalletId({
            uncheckedPaymentRequest: input.invoice,
            memo: input.memo,
            senderWalletId: walletId,
            senderAccount: account,
          })
          return paymentResult
        }
      },
    },
    {
      name: "directPay",
      fn: function fn({ walletId, account }: { walletId: WalletId; account: Account }) {
        return async (input): Promise<PaymentSendStatus | ApplicationError> => {
          const paymentResult = await Payments.payInvoiceByWalletId({
            uncheckedPaymentRequest: input.invoice,
            senderAccount: account,
            memo: input.memo,
            senderWalletId: walletId,
          })
          return paymentResult
        }
      },
    },
  ]

  functionToTests.forEach(({ fn, name }) => {
    describe(`${name}`, () => {
      it("pay invoice", async () => {
        const { request } = await createInvoice({
          lnd: lndOutside1,
          tokens: amountInvoice,
        })
        const result = await fn({ account: accountB, walletId: walletIdB })({
          invoice: request,
        })
        if (result instanceof Error) throw result
        expect(result).toBe(PaymentSendStatus.Success)

        const finalBalance = await getBalanceHelper(walletIdB)
        expect(finalBalance).toBe(initBalanceB - amountInvoice)
      })
    })
  })
})

describe("UserWalletLimit - handles 1 sat send with high btc outgoing volume", () => {
  const usdLimit = toCents(100_000)

  const accountLimits = {
    intraLedgerLimit: usdLimit,
    withdrawalLimit: usdLimit,
    tradeIntraAccountLimit: usdLimit,
  }

  const walletVolumes = [
    {
      outgoingBaseAmount: {
        amount: BigInt(usdLimit),
        currency: WalletCurrency.Btc,
      },
      incomingBaseAmount: { amount: 0n, currency: WalletCurrency.Btc },
    },
    {
      outgoingBaseAmount: { amount: 0n, currency: WalletCurrency.Usd },
      incomingBaseAmount: { amount: 0n, currency: WalletCurrency.Usd },
    },
  ]

  const mockedCheckWithdrawalLimits = ({
    amount,
    priceRatio,
  }: {
    amount: UsdPaymentAmount
    priceRatio: WalletPriceRatio
  }) => {
    return AccountLimitsChecker({
      accountLimits,
      priceRatio,
    }).checkWithdrawal({
      amount,
      walletVolumes,
    })
  }

  const mockedCheckIntraledgerLimits = ({
    amount,
    priceRatio,
  }: {
    amount: UsdPaymentAmount
    priceRatio: WalletPriceRatio
  }) => {
    return AccountLimitsChecker({
      accountLimits,
      priceRatio,
    }).checkIntraledger({
      amount,
      walletVolumes,
    })
  }

  it("estimate fee for zero amount invoice with 1 sat amount", async () => {
    jest
      .spyOn(PaymentsHelpers, "checkWithdrawalLimits")
      .mockImplementationOnce(mockedCheckWithdrawalLimits)
      .mockImplementationOnce(mockedCheckWithdrawalLimits)

    const senderWalletId = walletIdB
    const { request } = await createInvoice({ lnd: lndOutside1 })

    // Estimate fee with 2,000 sats
    const { error } = await Payments.getNoAmountLightningFeeEstimationForBtcWallet({
      walletId: senderWalletId,
      uncheckedPaymentRequest: request,
      amount: toSats(2_000),
    })
    expect(error).not.toBeInstanceOf(Error)

    // Estimate fee with 1 sat
    // This tests that a suitable WalletPriceRatio is passed into limits checker
    const { error: error1Sat } =
      await Payments.getNoAmountLightningFeeEstimationForBtcWallet({
        walletId: senderWalletId,
        uncheckedPaymentRequest: request,
        amount: toSats(1),
      })
    expect(error1Sat).not.toBeInstanceOf(Error)
  })

  it("pay zero amount invoice with 1 sat amount", async () => {
    jest
      .spyOn(PaymentsHelpers, "checkWithdrawalLimits")
      .mockImplementationOnce(mockedCheckWithdrawalLimits)

    const senderWalletId = walletIdB
    const senderAccount = accountB
    const { request } = await createInvoice({ lnd: lndOutside1 })

    const paid = await Payments.payNoAmountInvoiceByWalletIdForBtcWallet({
      senderWalletId,
      senderAccount,
      uncheckedPaymentRequest: request,
      amount: toSats(1),
      memo: "",
    })
    expect(paid).not.toBeInstanceOf(Error)
  })

  it("pay other Galoy user with 1 sat amount", async () => {
    jest
      .spyOn(PaymentsHelpers, "checkIntraledgerLimits")
      .mockImplementationOnce(mockedCheckIntraledgerLimits)

    const senderWalletId = walletIdB
    const senderAccount = accountB
    const paidIntraledger = Payments.intraledgerPaymentSendWalletIdForBtcWallet({
      senderWalletId,
      senderAccount,
      recipientWalletId: walletIdC,
      amount: toSats(1),
      memo: "",
    })
    expect(paidIntraledger).not.toBeInstanceOf(Error)
  })
})
