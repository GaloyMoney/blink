// this file is autogenerated by codegen
/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An Opaque Bearer token */
  AuthToken: string;
  /** (Positive) Cent amount (1/100 of a dollar) */
  CentAmount: number;
  /** An alias name that a user can set for a wallet (with which they have transactions) */
  ContactAlias: string;
  /** A CCA2 country code (ex US, FR, etc) */
  CountryCode: string;
  /** Display currency of an account */
  DisplayCurrency: string;
  /** Email address */
  EmailAddress: string;
  /** An id to be passed between registrationInitiate and registrationValidate for confirming email */
  EmailRegistrationId: string;
  EndpointId: string;
  /** Url that will be fetched on events for the account */
  EndpointUrl: string;
  /** Feedback shared with our user */
  Feedback: string;
  /** Hex-encoded string of 32 bytes */
  Hex32Bytes: string;
  Language: string;
  LnPaymentPreImage: string;
  /** BOLT11 lightning invoice payment request with the amount included */
  LnPaymentRequest: string;
  LnPaymentSecret: string;
  /** Text field in a lightning payment transaction */
  Memo: string;
  /** (Positive) amount of minutes */
  Minutes: string;
  NotificationCategory: string;
  /** An address for an on-chain bitcoin destination */
  OnChainAddress: string;
  OnChainTxHash: string;
  /** An authentication code valid for a single use */
  OneTimeAuthCode: string;
  PaymentHash: string;
  /** Phone number which includes country code */
  Phone: string;
  /** Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1 */
  SafeInt: number;
  /** (Positive) Satoshi amount */
  SatAmount: number;
  /** (Positive) amount of seconds */
  Seconds: number;
  /** An amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedAmount: number;
  /** A string amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedDisplayMajorAmount: string;
  /** Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch) */
  Timestamp: number;
  /** A time-based one-time password */
  TotpCode: string;
  /** An id to be passed between set and verify for confirming totp */
  TotpRegistrationId: string;
  /** A secret to generate time-based one-time password */
  TotpSecret: string;
  /** Unique identifier of a user */
  Username: string;
  /** Unique identifier of a wallet */
  WalletId: string;
  _FieldSet: string;
};

export type Account = {
  readonly callbackEndpoints: ReadonlyArray<CallbackEndpoint>;
  readonly csvTransactions: Scalars['String'];
  readonly defaultWallet: PublicWallet;
  /** @deprecated Shifting property to 'defaultWallet.id' */
  readonly defaultWalletId: Scalars['WalletId'];
  readonly displayCurrency: Scalars['DisplayCurrency'];
  readonly id: Scalars['ID'];
  readonly invoices?: Maybe<InvoiceConnection>;
  readonly level: AccountLevel;
  readonly limits: AccountLimits;
  readonly notificationSettings: NotificationSettings;
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  readonly realtimePrice: RealtimePrice;
  readonly transactions?: Maybe<TransactionConnection>;
  readonly walletById: Wallet;
  readonly wallets: ReadonlyArray<Wallet>;
};


export type AccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars['WalletId']>;
};


export type AccountInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']>>>;
};


export type AccountPendingIncomingTransactionsArgs = {
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']>>>;
};


export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']>>>;
};


export type AccountWalletByIdArgs = {
  walletId: Scalars['WalletId'];
};

export type AccountDeletePayload = {
  readonly __typename: 'AccountDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly success: Scalars['Boolean'];
};

export type AccountDisableNotificationCategoryInput = {
  readonly category: Scalars['NotificationCategory'];
  readonly channel?: InputMaybe<NotificationChannel>;
};

export type AccountDisableNotificationChannelInput = {
  readonly channel: NotificationChannel;
};

export type AccountEnableNotificationCategoryInput = {
  readonly category: Scalars['NotificationCategory'];
  readonly channel?: InputMaybe<NotificationChannel>;
};

export type AccountEnableNotificationChannelInput = {
  readonly channel: NotificationChannel;
};

export const AccountLevel = {
  One: 'ONE',
  Two: 'TWO',
  Zero: 'ZERO'
} as const;

export type AccountLevel = typeof AccountLevel[keyof typeof AccountLevel];
export type AccountLimit = {
  /** The rolling time interval in seconds that the limits would apply for. */
  readonly interval?: Maybe<Scalars['Seconds']>;
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars['CentAmount']>;
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars['CentAmount'];
};

export type AccountLimits = {
  readonly __typename: 'AccountLimits';
  /** Limits for converting between currencies among a account's own wallets. */
  readonly convert: ReadonlyArray<AccountLimit>;
  /** Limits for sending to other internal accounts. */
  readonly internalSend: ReadonlyArray<AccountLimit>;
  /** Limits for withdrawing to external onchain or lightning destinations. */
  readonly withdrawal: ReadonlyArray<AccountLimit>;
};

export type AccountUpdateDefaultWalletIdInput = {
  readonly walletId: Scalars['WalletId'];
};

export type AccountUpdateDefaultWalletIdPayload = {
  readonly __typename: 'AccountUpdateDefaultWalletIdPayload';
  readonly account?: Maybe<ConsumerAccount>;
  readonly errors: ReadonlyArray<Error>;
};

export type AccountUpdateDisplayCurrencyInput = {
  readonly currency: Scalars['DisplayCurrency'];
};

export type AccountUpdateDisplayCurrencyPayload = {
  readonly __typename: 'AccountUpdateDisplayCurrencyPayload';
  readonly account?: Maybe<ConsumerAccount>;
  readonly errors: ReadonlyArray<Error>;
};

export type AccountUpdateNotificationSettingsPayload = {
  readonly __typename: 'AccountUpdateNotificationSettingsPayload';
  readonly account?: Maybe<ConsumerAccount>;
  readonly errors: ReadonlyArray<Error>;
};

export type AuthTokenPayload = {
  readonly __typename: 'AuthTokenPayload';
  readonly authToken?: Maybe<Scalars['AuthToken']>;
  readonly errors: ReadonlyArray<Error>;
  readonly totpRequired?: Maybe<Scalars['Boolean']>;
};

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWallet = Wallet & {
  readonly __typename: 'BTCWallet';
  readonly accountId: Scalars['ID'];
  /** A balance stored in BTC. */
  readonly balance: Scalars['SignedAmount'];
  readonly id: Scalars['ID'];
  readonly invoiceByPaymentHash: Invoice;
  /** A list of all invoices associated with walletIds optionally passed. */
  readonly invoices?: Maybe<InvoiceConnection>;
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars['SignedAmount'];
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  readonly pendingIncomingTransactionsByAddress: ReadonlyArray<Transaction>;
  readonly transactionById: Transaction;
  /** A list of BTC transactions associated with this wallet. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly transactionsByPaymentHash: ReadonlyArray<Transaction>;
  readonly transactionsByPaymentRequest: ReadonlyArray<Transaction>;
  readonly walletCurrency: WalletCurrency;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletInvoiceByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletPendingIncomingTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionByIdArgs = {
  transactionId: Scalars['ID'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByPaymentRequestArgs = {
  paymentRequest: Scalars['LnPaymentRequest'];
};

export type BuildInformation = {
  readonly __typename: 'BuildInformation';
  readonly commitHash?: Maybe<Scalars['String']>;
  readonly helmRevision?: Maybe<Scalars['Int']>;
};

export type CallbackEndpoint = {
  readonly __typename: 'CallbackEndpoint';
  readonly id: Scalars['EndpointId'];
  readonly url: Scalars['EndpointUrl'];
};

export type CallbackEndpointAddInput = {
  /** callback endpoint to be called */
  readonly url: Scalars['EndpointUrl'];
};

export type CallbackEndpointAddPayload = {
  readonly __typename: 'CallbackEndpointAddPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly id?: Maybe<Scalars['EndpointId']>;
};

export type CallbackEndpointDeleteInput = {
  readonly id: Scalars['EndpointId'];
};

export type CaptchaCreateChallengePayload = {
  readonly __typename: 'CaptchaCreateChallengePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly result?: Maybe<CaptchaCreateChallengeResult>;
};

export type CaptchaCreateChallengeResult = {
  readonly __typename: 'CaptchaCreateChallengeResult';
  readonly challengeCode: Scalars['String'];
  readonly failbackMode: Scalars['Boolean'];
  readonly id: Scalars['String'];
  readonly newCaptcha: Scalars['Boolean'];
};

export type CaptchaRequestAuthCodeInput = {
  readonly challengeCode: Scalars['String'];
  readonly channel?: InputMaybe<PhoneCodeChannelType>;
  readonly phone: Scalars['Phone'];
  readonly secCode: Scalars['String'];
  readonly validationCode: Scalars['String'];
};

export type CentAmountPayload = {
  readonly __typename: 'CentAmountPayload';
  readonly amount?: Maybe<Scalars['CentAmount']>;
  readonly errors: ReadonlyArray<Error>;
};

export type ConsumerAccount = Account & {
  readonly __typename: 'ConsumerAccount';
  readonly callbackEndpoints: ReadonlyArray<CallbackEndpoint>;
  /** return CSV stream, base64 encoded, of the list of transactions in the wallet */
  readonly csvTransactions: Scalars['String'];
  readonly defaultWallet: PublicWallet;
  readonly defaultWalletId: Scalars['WalletId'];
  readonly displayCurrency: Scalars['DisplayCurrency'];
  readonly id: Scalars['ID'];
  /** A list of all invoices associated with walletIds optionally passed. */
  readonly invoices?: Maybe<InvoiceConnection>;
  readonly level: AccountLevel;
  readonly limits: AccountLimits;
  readonly notificationSettings: NotificationSettings;
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  /** List the quiz questions of the consumer account */
  readonly quiz: ReadonlyArray<Quiz>;
  readonly realtimePrice: RealtimePrice;
  /** A list of all transactions associated with walletIds optionally passed. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly walletById: Wallet;
  readonly wallets: ReadonlyArray<Wallet>;
};


export type ConsumerAccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars['WalletId']>;
};


export type ConsumerAccountInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']>>>;
};


export type ConsumerAccountPendingIncomingTransactionsArgs = {
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']>>>;
};


export type ConsumerAccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']>>>;
};


export type ConsumerAccountWalletByIdArgs = {
  walletId: Scalars['WalletId'];
};

export type Coordinates = {
  readonly __typename: 'Coordinates';
  readonly latitude: Scalars['Float'];
  readonly longitude: Scalars['Float'];
};

export type Country = {
  readonly __typename: 'Country';
  readonly id: Scalars['CountryCode'];
  readonly supportedAuthChannels: ReadonlyArray<PhoneCodeChannelType>;
};

export type Currency = {
  readonly __typename: 'Currency';
  readonly flag: Scalars['String'];
  readonly fractionDigits: Scalars['Int'];
  readonly id: Scalars['ID'];
  readonly name: Scalars['String'];
  readonly symbol: Scalars['String'];
};

export type DepositFeesInformation = {
  readonly __typename: 'DepositFeesInformation';
  readonly minBankFee: Scalars['String'];
  /** below this amount minBankFee will be charged */
  readonly minBankFeeThreshold: Scalars['String'];
  /** ratio to charge as basis points above minBankFeeThreshold amount */
  readonly ratio: Scalars['String'];
};

export type DeviceNotificationTokenCreateInput = {
  readonly deviceToken: Scalars['String'];
};

export type Email = {
  readonly __typename: 'Email';
  readonly address?: Maybe<Scalars['EmailAddress']>;
  readonly verified?: Maybe<Scalars['Boolean']>;
};

export type Error = {
  readonly code?: Maybe<Scalars['String']>;
  readonly message: Scalars['String'];
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

export const ExchangeCurrencyUnit = {
  Btcsat: 'BTCSAT',
  Usdcent: 'USDCENT'
} as const;

export type ExchangeCurrencyUnit = typeof ExchangeCurrencyUnit[keyof typeof ExchangeCurrencyUnit];
export type FeedbackSubmitInput = {
  readonly feedback: Scalars['Feedback'];
};

export type FeesInformation = {
  readonly __typename: 'FeesInformation';
  readonly deposit: DepositFeesInformation;
};

/** Provides global settings for the application which might have an impact for the user. */
export type Globals = {
  readonly __typename: 'Globals';
  readonly buildInformation: BuildInformation;
  readonly feesInformation: FeesInformation;
  /** The domain name for lightning addresses accepted by this Galoy instance */
  readonly lightningAddressDomain: Scalars['String'];
  readonly lightningAddressDomainAliases: ReadonlyArray<Scalars['String']>;
  /** Which network (mainnet, testnet, regtest, signet) this instance is running on. */
  readonly network: Network;
  /**
   * A list of public keys for the running lightning nodes.
   * This can be used to know if an invoice belongs to one of our nodes.
   */
  readonly nodesIds: ReadonlyArray<Scalars['String']>;
  /** A list of countries and their supported auth channels */
  readonly supportedCountries: ReadonlyArray<Country>;
};

export type GraphQlApplicationError = Error & {
  readonly __typename: 'GraphQLApplicationError';
  readonly code?: Maybe<Scalars['String']>;
  readonly message: Scalars['String'];
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

export type InitiationVia = InitiationViaIntraLedger | InitiationViaLn | InitiationViaOnChain;

export type InitiationViaIntraLedger = {
  readonly __typename: 'InitiationViaIntraLedger';
  readonly counterPartyUsername?: Maybe<Scalars['Username']>;
  readonly counterPartyWalletId?: Maybe<Scalars['WalletId']>;
};

export type InitiationViaLn = {
  readonly __typename: 'InitiationViaLn';
  readonly paymentHash: Scalars['PaymentHash'];
  /** Bolt11 invoice */
  readonly paymentRequest: Scalars['LnPaymentRequest'];
};

export type InitiationViaOnChain = {
  readonly __typename: 'InitiationViaOnChain';
  readonly address: Scalars['OnChainAddress'];
};

export type IntraLedgerPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount'];
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  readonly recipientWalletId: Scalars['WalletId'];
  /** The wallet ID of the sender. */
  readonly walletId: Scalars['WalletId'];
};

export type IntraLedgerUpdate = {
  readonly __typename: 'IntraLedgerUpdate';
  /** @deprecated Deprecated in favor of transaction */
  readonly amount: Scalars['SatAmount'];
  /** @deprecated Deprecated in favor of transaction */
  readonly displayCurrencyPerSat: Scalars['Float'];
  readonly transaction: Transaction;
  readonly txNotificationType: TxNotificationType;
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars['Float'];
  /** @deprecated Deprecated in favor of transaction */
  readonly walletId: Scalars['WalletId'];
};

export type IntraLedgerUsdPaymentSendInput = {
  /** Amount in cents. */
  readonly amount: Scalars['CentAmount'];
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  readonly recipientWalletId: Scalars['WalletId'];
  /** The wallet ID of the sender. */
  readonly walletId: Scalars['WalletId'];
};

/** A lightning invoice. */
export type Invoice = {
  readonly createdAt: Scalars['Timestamp'];
  /** The payment hash of the lightning invoice. */
  readonly paymentHash: Scalars['PaymentHash'];
  /** The bolt11 invoice to be paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  /** The payment secret of the lightning invoice. This is not the preimage of the payment hash. */
  readonly paymentSecret: Scalars['LnPaymentSecret'];
  /** The payment status of the invoice. */
  readonly paymentStatus: InvoicePaymentStatus;
};

/** A connection to a list of items. */
export type InvoiceConnection = {
  readonly __typename: 'InvoiceConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<InvoiceEdge>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InvoiceEdge = {
  readonly __typename: 'InvoiceEdge';
  /** A cursor for use in pagination */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge */
  readonly node: Invoice;
};

export const InvoicePaymentStatus = {
  Expired: 'EXPIRED',
  Paid: 'PAID',
  Pending: 'PENDING'
} as const;

export type InvoicePaymentStatus = typeof InvoicePaymentStatus[keyof typeof InvoicePaymentStatus];
export type LnAddressPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount'];
  /** Lightning address to send to. */
  readonly lnAddress: Scalars['String'];
  /** Wallet ID to send bitcoin from. */
  readonly walletId: Scalars['WalletId'];
};

export type LnInvoice = Invoice & {
  readonly __typename: 'LnInvoice';
  readonly createdAt: Scalars['Timestamp'];
  readonly paymentHash: Scalars['PaymentHash'];
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  readonly paymentSecret: Scalars['LnPaymentSecret'];
  readonly paymentStatus: InvoicePaymentStatus;
  readonly satoshis: Scalars['SatAmount'];
};

export type LnInvoiceCancelInput = {
  readonly paymentHash: Scalars['PaymentHash'];
  /** Wallet ID for a wallet associated with the current account. */
  readonly walletId: Scalars['WalletId'];
};

export type LnInvoiceCreateInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount'];
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Wallet ID for a BTC wallet belonging to the current account. */
  readonly walletId: Scalars['WalletId'];
};

export type LnInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount'];
  readonly descriptionHash?: InputMaybe<Scalars['Hex32Bytes']>;
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Wallet ID for a BTC wallet which belongs to any account. */
  readonly recipientWalletId: Scalars['WalletId'];
};

export type LnInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  readonly walletId: Scalars['WalletId'];
};

export type LnInvoicePayload = {
  readonly __typename: 'LnInvoicePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly invoice?: Maybe<LnInvoice>;
};

export type LnInvoicePaymentInput = {
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  /** Wallet ID with sufficient balance to cover amount of invoice.  Must belong to the account of the current user. */
  readonly walletId: Scalars['WalletId'];
};

export type LnInvoicePaymentStatus = {
  readonly __typename: 'LnInvoicePaymentStatus';
  readonly paymentHash?: Maybe<Scalars['PaymentHash']>;
  readonly paymentRequest?: Maybe<Scalars['LnPaymentRequest']>;
  readonly status?: Maybe<InvoicePaymentStatus>;
};

export type LnInvoicePaymentStatusByHashInput = {
  readonly paymentHash: Scalars['PaymentHash'];
};

export type LnInvoicePaymentStatusByPaymentRequestInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest'];
};

export type LnInvoicePaymentStatusInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest'];
};

export type LnInvoicePaymentStatusPayload = {
  readonly __typename: 'LnInvoicePaymentStatusPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly paymentHash?: Maybe<Scalars['PaymentHash']>;
  readonly paymentRequest?: Maybe<Scalars['LnPaymentRequest']>;
  readonly status?: Maybe<InvoicePaymentStatus>;
};

export type LnNoAmountInvoice = Invoice & {
  readonly __typename: 'LnNoAmountInvoice';
  readonly createdAt: Scalars['Timestamp'];
  readonly paymentHash: Scalars['PaymentHash'];
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  readonly paymentSecret: Scalars['LnPaymentSecret'];
  readonly paymentStatus: InvoicePaymentStatus;
};

export type LnNoAmountInvoiceCreateInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** ID for either a USD or BTC wallet belonging to the account of the current user. */
  readonly walletId: Scalars['WalletId'];
};

export type LnNoAmountInvoiceCreateOnBehalfOfRecipientInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** ID for either a USD or BTC wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars['WalletId'];
};

export type LnNoAmountInvoiceFeeProbeInput = {
  readonly amount: Scalars['SatAmount'];
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  readonly walletId: Scalars['WalletId'];
};

export type LnNoAmountInvoicePayload = {
  readonly __typename: 'LnNoAmountInvoicePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly invoice?: Maybe<LnNoAmountInvoice>;
};

export type LnNoAmountInvoicePaymentInput = {
  /** Amount to pay in satoshis. */
  readonly amount: Scalars['SatAmount'];
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars['WalletId'];
};

export type LnNoAmountUsdInvoiceFeeProbeInput = {
  readonly amount: Scalars['CentAmount'];
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  readonly walletId: Scalars['WalletId'];
};

export type LnNoAmountUsdInvoicePaymentInput = {
  /** Amount to pay in USD cents. */
  readonly amount: Scalars['CentAmount'];
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars['WalletId'];
};

export type LnUpdate = {
  readonly __typename: 'LnUpdate';
  /** @deprecated Deprecated in favor of transaction */
  readonly paymentHash: Scalars['PaymentHash'];
  readonly status: InvoicePaymentStatus;
  readonly transaction: Transaction;
  /** @deprecated Deprecated in favor of transaction */
  readonly walletId: Scalars['WalletId'];
};

export type LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount'];
  readonly descriptionHash?: InputMaybe<Scalars['Hex32Bytes']>;
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars['WalletId'];
};

export type LnUsdInvoiceCreateInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars['CentAmount'];
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Wallet ID for a USD wallet belonging to the current user. */
  readonly walletId: Scalars['WalletId'];
};

export type LnUsdInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars['CentAmount'];
  readonly descriptionHash?: InputMaybe<Scalars['Hex32Bytes']>;
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']>;
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars['Memo']>;
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars['WalletId'];
};

export type LnUsdInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest'];
  readonly walletId: Scalars['WalletId'];
};

export type LnurlPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount'];
  /** Lnurl string to send to. */
  readonly lnurl: Scalars['String'];
  /** Wallet ID to send bitcoin from. */
  readonly walletId: Scalars['WalletId'];
};

export type MapInfo = {
  readonly __typename: 'MapInfo';
  readonly coordinates: Coordinates;
  readonly title: Scalars['String'];
};

export type MapMarker = {
  readonly __typename: 'MapMarker';
  readonly mapInfo: MapInfo;
  readonly username: Scalars['Username'];
};

export type Merchant = {
  readonly __typename: 'Merchant';
  /** GPS coordinates for the merchant that can be used to place the related business on a map */
  readonly coordinates: Coordinates;
  readonly createdAt: Scalars['Timestamp'];
  readonly id: Scalars['ID'];
  readonly title: Scalars['String'];
  /** The username of the merchant */
  readonly username: Scalars['Username'];
  /** Whether the merchant has been validated */
  readonly validated: Scalars['Boolean'];
};

export type MerchantMapSuggestInput = {
  readonly latitude: Scalars['Float'];
  readonly longitude: Scalars['Float'];
  readonly title: Scalars['String'];
  readonly username: Scalars['Username'];
};

export type MerchantPayload = {
  readonly __typename: 'MerchantPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly merchant?: Maybe<Merchant>;
};

export type MobileVersions = {
  readonly __typename: 'MobileVersions';
  readonly currentSupported: Scalars['Int'];
  readonly minSupported: Scalars['Int'];
  readonly platform: Scalars['String'];
};

export type Mutation = {
  readonly __typename: 'Mutation';
  readonly accountDelete: AccountDeletePayload;
  readonly accountDisableNotificationCategory: AccountUpdateNotificationSettingsPayload;
  readonly accountDisableNotificationChannel: AccountUpdateNotificationSettingsPayload;
  readonly accountEnableNotificationCategory: AccountUpdateNotificationSettingsPayload;
  readonly accountEnableNotificationChannel: AccountUpdateNotificationSettingsPayload;
  readonly accountUpdateDefaultWalletId: AccountUpdateDefaultWalletIdPayload;
  readonly accountUpdateDisplayCurrency: AccountUpdateDisplayCurrencyPayload;
  readonly callbackEndpointAdd: CallbackEndpointAddPayload;
  readonly callbackEndpointDelete: SuccessPayload;
  readonly captchaCreateChallenge: CaptchaCreateChallengePayload;
  readonly captchaRequestAuthCode: SuccessPayload;
  readonly deviceNotificationTokenCreate: SuccessPayload;
  readonly feedbackSubmit: SuccessPayload;
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerPaymentSend: PaymentSendPayload;
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerUsdPaymentSend: PaymentSendPayload;
  /** Sends a payment to a lightning address. */
  readonly lnAddressPaymentSend: PaymentSendPayload;
  /** Cancel an unpaid lightning invoice for an associated wallet. */
  readonly lnInvoiceCancel: SuccessPayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreate: LnInvoicePayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload;
  readonly lnInvoiceFeeProbe: SatAmountPayload;
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet can be USD or BTC and must have sufficient balance to cover amount in lightning invoice.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnInvoicePaymentSend: PaymentSendPayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreate: LnNoAmountInvoicePayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreateOnBehalfOfRecipient: LnNoAmountInvoicePayload;
  readonly lnNoAmountInvoiceFeeProbe: SatAmountPayload;
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be BTC and must have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountInvoicePaymentSend: PaymentSendPayload;
  readonly lnNoAmountUsdInvoiceFeeProbe: CentAmountPayload;
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be USD and have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountUsdInvoicePaymentSend: PaymentSendPayload;
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipient: LnInvoicePayload;
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   * associated with the amount).
   */
  readonly lnUsdInvoiceCreate: LnInvoicePayload;
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload;
  readonly lnUsdInvoiceFeeProbe: SatAmountPayload;
  /** Sends a payment to a lightning address. */
  readonly lnurlPaymentSend: PaymentSendPayload;
  readonly merchantMapSuggest: MerchantPayload;
  readonly onChainAddressCreate: OnChainAddressPayload;
  readonly onChainAddressCurrent: OnChainAddressPayload;
  readonly onChainPaymentSend: PaymentSendPayload;
  readonly onChainPaymentSendAll: PaymentSendPayload;
  readonly onChainUsdPaymentSend: PaymentSendPayload;
  readonly onChainUsdPaymentSendAsBtcDenominated: PaymentSendPayload;
  readonly quizClaim: QuizClaimPayload;
  /** @deprecated will be moved to AccountContact */
  readonly userContactUpdateAlias: UserContactUpdateAliasPayload;
  readonly userEmailDelete: UserEmailDeletePayload;
  readonly userEmailRegistrationInitiate: UserEmailRegistrationInitiatePayload;
  readonly userEmailRegistrationValidate: UserEmailRegistrationValidatePayload;
  readonly userLogin: AuthTokenPayload;
  readonly userLoginUpgrade: UpgradePayload;
  readonly userLogout: SuccessPayload;
  readonly userPhoneDelete: UserPhoneDeletePayload;
  readonly userPhoneRegistrationInitiate: SuccessPayload;
  readonly userPhoneRegistrationValidate: UserPhoneRegistrationValidatePayload;
  readonly userTotpDelete: UserTotpDeletePayload;
  readonly userTotpRegistrationInitiate: UserTotpRegistrationInitiatePayload;
  readonly userTotpRegistrationValidate: UserTotpRegistrationValidatePayload;
  readonly userUpdateLanguage: UserUpdateLanguagePayload;
  /** @deprecated Username will be moved to @Handle in Accounts. Also SetUsername naming should be used instead of UpdateUsername to reflect the idempotency of Handles */
  readonly userUpdateUsername: UserUpdateUsernamePayload;
};


export type MutationAccountDisableNotificationCategoryArgs = {
  input: AccountDisableNotificationCategoryInput;
};


export type MutationAccountDisableNotificationChannelArgs = {
  input: AccountDisableNotificationChannelInput;
};


export type MutationAccountEnableNotificationCategoryArgs = {
  input: AccountEnableNotificationCategoryInput;
};


export type MutationAccountEnableNotificationChannelArgs = {
  input: AccountEnableNotificationChannelInput;
};


export type MutationAccountUpdateDefaultWalletIdArgs = {
  input: AccountUpdateDefaultWalletIdInput;
};


export type MutationAccountUpdateDisplayCurrencyArgs = {
  input: AccountUpdateDisplayCurrencyInput;
};


export type MutationCallbackEndpointAddArgs = {
  input: CallbackEndpointAddInput;
};


export type MutationCallbackEndpointDeleteArgs = {
  input: CallbackEndpointDeleteInput;
};


export type MutationCaptchaRequestAuthCodeArgs = {
  input: CaptchaRequestAuthCodeInput;
};


export type MutationDeviceNotificationTokenCreateArgs = {
  input: DeviceNotificationTokenCreateInput;
};


export type MutationFeedbackSubmitArgs = {
  input: FeedbackSubmitInput;
};


export type MutationIntraLedgerPaymentSendArgs = {
  input: IntraLedgerPaymentSendInput;
};


export type MutationIntraLedgerUsdPaymentSendArgs = {
  input: IntraLedgerUsdPaymentSendInput;
};


export type MutationLnAddressPaymentSendArgs = {
  input: LnAddressPaymentSendInput;
};


export type MutationLnInvoiceCancelArgs = {
  input: LnInvoiceCancelInput;
};


export type MutationLnInvoiceCreateArgs = {
  input: LnInvoiceCreateInput;
};


export type MutationLnInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnInvoiceCreateOnBehalfOfRecipientInput;
};


export type MutationLnInvoiceFeeProbeArgs = {
  input: LnInvoiceFeeProbeInput;
};


export type MutationLnInvoicePaymentSendArgs = {
  input: LnInvoicePaymentInput;
};


export type MutationLnNoAmountInvoiceCreateArgs = {
  input: LnNoAmountInvoiceCreateInput;
};


export type MutationLnNoAmountInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput;
};


export type MutationLnNoAmountInvoiceFeeProbeArgs = {
  input: LnNoAmountInvoiceFeeProbeInput;
};


export type MutationLnNoAmountInvoicePaymentSendArgs = {
  input: LnNoAmountInvoicePaymentInput;
};


export type MutationLnNoAmountUsdInvoiceFeeProbeArgs = {
  input: LnNoAmountUsdInvoiceFeeProbeInput;
};


export type MutationLnNoAmountUsdInvoicePaymentSendArgs = {
  input: LnNoAmountUsdInvoicePaymentInput;
};


export type MutationLnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput;
};


export type MutationLnUsdInvoiceCreateArgs = {
  input: LnUsdInvoiceCreateInput;
};


export type MutationLnUsdInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceCreateOnBehalfOfRecipientInput;
};


export type MutationLnUsdInvoiceFeeProbeArgs = {
  input: LnUsdInvoiceFeeProbeInput;
};


export type MutationLnurlPaymentSendArgs = {
  input: LnurlPaymentSendInput;
};


export type MutationMerchantMapSuggestArgs = {
  input: MerchantMapSuggestInput;
};


export type MutationOnChainAddressCreateArgs = {
  input: OnChainAddressCreateInput;
};


export type MutationOnChainAddressCurrentArgs = {
  input: OnChainAddressCurrentInput;
};


export type MutationOnChainPaymentSendArgs = {
  input: OnChainPaymentSendInput;
};


export type MutationOnChainPaymentSendAllArgs = {
  input: OnChainPaymentSendAllInput;
};


export type MutationOnChainUsdPaymentSendArgs = {
  input: OnChainUsdPaymentSendInput;
};


export type MutationOnChainUsdPaymentSendAsBtcDenominatedArgs = {
  input: OnChainUsdPaymentSendAsBtcDenominatedInput;
};


export type MutationQuizClaimArgs = {
  input: QuizClaimInput;
};


export type MutationUserContactUpdateAliasArgs = {
  input: UserContactUpdateAliasInput;
};


export type MutationUserEmailRegistrationInitiateArgs = {
  input: UserEmailRegistrationInitiateInput;
};


export type MutationUserEmailRegistrationValidateArgs = {
  input: UserEmailRegistrationValidateInput;
};


export type MutationUserLoginArgs = {
  input: UserLoginInput;
};


export type MutationUserLoginUpgradeArgs = {
  input: UserLoginUpgradeInput;
};


export type MutationUserLogoutArgs = {
  input?: InputMaybe<UserLogoutInput>;
};


export type MutationUserPhoneRegistrationInitiateArgs = {
  input: UserPhoneRegistrationInitiateInput;
};


export type MutationUserPhoneRegistrationValidateArgs = {
  input: UserPhoneRegistrationValidateInput;
};


export type MutationUserTotpRegistrationValidateArgs = {
  input: UserTotpRegistrationValidateInput;
};


export type MutationUserUpdateLanguageArgs = {
  input: UserUpdateLanguageInput;
};


export type MutationUserUpdateUsernameArgs = {
  input: UserUpdateUsernameInput;
};

export type MyUpdatesPayload = {
  readonly __typename: 'MyUpdatesPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
  readonly update?: Maybe<UserUpdate>;
};

export const Network = {
  Mainnet: 'mainnet',
  Regtest: 'regtest',
  Signet: 'signet',
  Testnet: 'testnet'
} as const;

export type Network = typeof Network[keyof typeof Network];
export const NotificationChannel = {
  Push: 'PUSH'
} as const;

export type NotificationChannel = typeof NotificationChannel[keyof typeof NotificationChannel];
export type NotificationChannelSettings = {
  readonly __typename: 'NotificationChannelSettings';
  readonly disabledCategories: ReadonlyArray<Scalars['NotificationCategory']>;
  readonly enabled: Scalars['Boolean'];
};

export type NotificationSettings = {
  readonly __typename: 'NotificationSettings';
  readonly push: NotificationChannelSettings;
};

export type OnChainAddressCreateInput = {
  readonly walletId: Scalars['WalletId'];
};

export type OnChainAddressCurrentInput = {
  readonly walletId: Scalars['WalletId'];
};

export type OnChainAddressPayload = {
  readonly __typename: 'OnChainAddressPayload';
  readonly address?: Maybe<Scalars['OnChainAddress']>;
  readonly errors: ReadonlyArray<Error>;
};

export type OnChainPaymentSendAllInput = {
  readonly address: Scalars['OnChainAddress'];
  readonly memo?: InputMaybe<Scalars['Memo']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId'];
};

export type OnChainPaymentSendInput = {
  readonly address: Scalars['OnChainAddress'];
  readonly amount: Scalars['SatAmount'];
  readonly memo?: InputMaybe<Scalars['Memo']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId'];
};

export type OnChainTxFee = {
  readonly __typename: 'OnChainTxFee';
  readonly amount: Scalars['SatAmount'];
};

export type OnChainUpdate = {
  readonly __typename: 'OnChainUpdate';
  /** @deprecated Deprecated in favor of transaction */
  readonly amount: Scalars['SatAmount'];
  /** @deprecated Deprecated in favor of transaction */
  readonly displayCurrencyPerSat: Scalars['Float'];
  readonly transaction: Transaction;
  /** @deprecated Deprecated in favor of transaction */
  readonly txHash: Scalars['OnChainTxHash'];
  readonly txNotificationType: TxNotificationType;
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars['Float'];
  /** @deprecated Deprecated in favor of transaction */
  readonly walletId: Scalars['WalletId'];
};

export type OnChainUsdPaymentSendAsBtcDenominatedInput = {
  readonly address: Scalars['OnChainAddress'];
  readonly amount: Scalars['SatAmount'];
  readonly memo?: InputMaybe<Scalars['Memo']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId'];
};

export type OnChainUsdPaymentSendInput = {
  readonly address: Scalars['OnChainAddress'];
  readonly amount: Scalars['CentAmount'];
  readonly memo?: InputMaybe<Scalars['Memo']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId'];
};

export type OnChainUsdTxFee = {
  readonly __typename: 'OnChainUsdTxFee';
  readonly amount: Scalars['CentAmount'];
};

export type OneDayAccountLimit = AccountLimit & {
  readonly __typename: 'OneDayAccountLimit';
  /** The rolling time interval value in seconds for the current 24 hour period. */
  readonly interval?: Maybe<Scalars['Seconds']>;
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars['CentAmount']>;
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars['CentAmount'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  readonly __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars['String']>;
};

export type PaymentSendPayload = {
  readonly __typename: 'PaymentSendPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly status?: Maybe<PaymentSendResult>;
  readonly transaction?: Maybe<Transaction>;
};

export const PaymentSendResult = {
  AlreadyPaid: 'ALREADY_PAID',
  Failure: 'FAILURE',
  Pending: 'PENDING',
  Success: 'SUCCESS'
} as const;

export type PaymentSendResult = typeof PaymentSendResult[keyof typeof PaymentSendResult];
export const PayoutSpeed = {
  Fast: 'FAST'
} as const;

export type PayoutSpeed = typeof PayoutSpeed[keyof typeof PayoutSpeed];
export const PhoneCodeChannelType = {
  Sms: 'SMS',
  Whatsapp: 'WHATSAPP'
} as const;

export type PhoneCodeChannelType = typeof PhoneCodeChannelType[keyof typeof PhoneCodeChannelType];
/** Price amount expressed in base/offset. To calculate, use: `base / 10^offset` */
export type Price = {
  readonly __typename: 'Price';
  readonly base: Scalars['SafeInt'];
  readonly currencyUnit: Scalars['String'];
  readonly formattedAmount: Scalars['String'];
  readonly offset: Scalars['Int'];
};

/** The range for the X axis in the BTC price graph */
export const PriceGraphRange = {
  FiveYears: 'FIVE_YEARS',
  OneDay: 'ONE_DAY',
  OneMonth: 'ONE_MONTH',
  OneWeek: 'ONE_WEEK',
  OneYear: 'ONE_YEAR'
} as const;

export type PriceGraphRange = typeof PriceGraphRange[keyof typeof PriceGraphRange];
export type PriceInput = {
  readonly amount: Scalars['SatAmount'];
  readonly amountCurrencyUnit: ExchangeCurrencyUnit;
  readonly priceCurrencyUnit: ExchangeCurrencyUnit;
};

export type PriceInterface = {
  readonly base: Scalars['SafeInt'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String'];
  readonly offset: Scalars['Int'];
};

/** Price of 1 sat in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSatInMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneSatInMinorUnit';
  readonly base: Scalars['SafeInt'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String'];
  readonly offset: Scalars['Int'];
};

/** Price of 1 sat or 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSettlementMinorUnitInDisplayMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit';
  readonly base: Scalars['SafeInt'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String'];
  /** @deprecated Deprecated please use `base / 10^offset` */
  readonly formattedAmount: Scalars['String'];
  readonly offset: Scalars['Int'];
};

/** Price of 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneUsdCentInMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneUsdCentInMinorUnit';
  readonly base: Scalars['SafeInt'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String'];
  readonly offset: Scalars['Int'];
};

export type PricePayload = {
  readonly __typename: 'PricePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly price?: Maybe<Price>;
};

export type PricePoint = {
  readonly __typename: 'PricePoint';
  readonly price: Price;
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars['Timestamp'];
};

/** A public view of a generic wallet which stores value in one of our supported currencies. */
export type PublicWallet = {
  readonly __typename: 'PublicWallet';
  readonly currency: WalletCurrency;
  readonly id: Scalars['ID'];
  /** @deprecated Shifting property to 'currency' */
  readonly walletCurrency: WalletCurrency;
};

export type Query = {
  readonly __typename: 'Query';
  readonly accountDefaultWallet: PublicWallet;
  readonly btcPriceList?: Maybe<ReadonlyArray<Maybe<PricePoint>>>;
  readonly businessMapMarkers: ReadonlyArray<MapMarker>;
  readonly currencyList: ReadonlyArray<Currency>;
  readonly globals?: Maybe<Globals>;
  /** @deprecated Deprecated in favor of lnInvoicePaymentStatusByPaymentRequest */
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload;
  readonly lnInvoicePaymentStatusByHash: LnInvoicePaymentStatus;
  readonly lnInvoicePaymentStatusByPaymentRequest: LnInvoicePaymentStatus;
  readonly me?: Maybe<User>;
  readonly mobileVersions?: Maybe<ReadonlyArray<Maybe<MobileVersions>>>;
  readonly onChainTxFee: OnChainTxFee;
  readonly onChainUsdTxFee: OnChainUsdTxFee;
  readonly onChainUsdTxFeeAsBtcDenominated: OnChainUsdTxFee;
  /** Returns 1 Sat and 1 Usd Cent price for the given currency */
  readonly realtimePrice: RealtimePrice;
  /** @deprecated will be migrated to AccountDefaultWalletId */
  readonly userDefaultWalletId: Scalars['WalletId'];
  readonly usernameAvailable?: Maybe<Scalars['Boolean']>;
};


export type QueryAccountDefaultWalletArgs = {
  username: Scalars['Username'];
  walletCurrency?: InputMaybe<WalletCurrency>;
};


export type QueryBtcPriceListArgs = {
  range: PriceGraphRange;
};


export type QueryLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput;
};


export type QueryLnInvoicePaymentStatusByHashArgs = {
  input: LnInvoicePaymentStatusByHashInput;
};


export type QueryLnInvoicePaymentStatusByPaymentRequestArgs = {
  input: LnInvoicePaymentStatusByPaymentRequestInput;
};


export type QueryOnChainTxFeeArgs = {
  address: Scalars['OnChainAddress'];
  amount: Scalars['SatAmount'];
  speed?: PayoutSpeed;
  walletId: Scalars['WalletId'];
};


export type QueryOnChainUsdTxFeeArgs = {
  address: Scalars['OnChainAddress'];
  amount: Scalars['CentAmount'];
  speed?: PayoutSpeed;
  walletId: Scalars['WalletId'];
};


export type QueryOnChainUsdTxFeeAsBtcDenominatedArgs = {
  address: Scalars['OnChainAddress'];
  amount: Scalars['SatAmount'];
  speed?: PayoutSpeed;
  walletId: Scalars['WalletId'];
};


export type QueryRealtimePriceArgs = {
  currency?: InputMaybe<Scalars['DisplayCurrency']>;
};


export type QueryUserDefaultWalletIdArgs = {
  username: Scalars['Username'];
};


export type QueryUsernameAvailableArgs = {
  username: Scalars['Username'];
};

export type Quiz = {
  readonly __typename: 'Quiz';
  /** The reward in Satoshis for the quiz question */
  readonly amount: Scalars['SatAmount'];
  readonly completed: Scalars['Boolean'];
  readonly id: Scalars['ID'];
  readonly notBefore?: Maybe<Scalars['Timestamp']>;
};

export type QuizClaimInput = {
  readonly id: Scalars['ID'];
};

export type QuizClaimPayload = {
  readonly __typename: 'QuizClaimPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly quizzes: ReadonlyArray<Quiz>;
};

export type RealtimePrice = {
  readonly __typename: 'RealtimePrice';
  readonly btcSatPrice: PriceOfOneSatInMinorUnit;
  readonly denominatorCurrency: Scalars['DisplayCurrency'];
  readonly id: Scalars['ID'];
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars['Timestamp'];
  readonly usdCentPrice: PriceOfOneUsdCentInMinorUnit;
};

export type RealtimePriceInput = {
  readonly currency?: InputMaybe<Scalars['DisplayCurrency']>;
};

export type RealtimePricePayload = {
  readonly __typename: 'RealtimePricePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly realtimePrice?: Maybe<RealtimePrice>;
};

export type SatAmountPayload = {
  readonly __typename: 'SatAmountPayload';
  readonly amount?: Maybe<Scalars['SatAmount']>;
  readonly errors: ReadonlyArray<Error>;
};

export type SettlementVia = SettlementViaIntraLedger | SettlementViaLn | SettlementViaOnChain;

export type SettlementViaIntraLedger = {
  readonly __typename: 'SettlementViaIntraLedger';
  /** Settlement destination: Could be null if the payee does not have a username */
  readonly counterPartyUsername?: Maybe<Scalars['Username']>;
  readonly counterPartyWalletId?: Maybe<Scalars['WalletId']>;
  readonly preImage?: Maybe<Scalars['LnPaymentPreImage']>;
};

export type SettlementViaLn = {
  readonly __typename: 'SettlementViaLn';
  /** @deprecated Shifting property to 'preImage' to improve granularity of the LnPaymentSecret type */
  readonly paymentSecret?: Maybe<Scalars['LnPaymentSecret']>;
  readonly preImage?: Maybe<Scalars['LnPaymentPreImage']>;
};

export type SettlementViaOnChain = {
  readonly __typename: 'SettlementViaOnChain';
  readonly arrivalInMempoolEstimatedAt?: Maybe<Scalars['Timestamp']>;
  readonly transactionHash?: Maybe<Scalars['OnChainTxHash']>;
  readonly vout?: Maybe<Scalars['Int']>;
};

export type Subscription = {
  readonly __typename: 'Subscription';
  /** @deprecated Deprecated in favor of lnInvoicePaymentStatusByPaymentRequest */
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload;
  readonly lnInvoicePaymentStatusByHash: LnInvoicePaymentStatusPayload;
  readonly lnInvoicePaymentStatusByPaymentRequest: LnInvoicePaymentStatusPayload;
  readonly myUpdates: MyUpdatesPayload;
  readonly price: PricePayload;
  /** Returns the price of 1 satoshi */
  readonly realtimePrice: RealtimePricePayload;
};


export type SubscriptionLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput;
};


export type SubscriptionLnInvoicePaymentStatusByHashArgs = {
  input: LnInvoicePaymentStatusByHashInput;
};


export type SubscriptionLnInvoicePaymentStatusByPaymentRequestArgs = {
  input: LnInvoicePaymentStatusByPaymentRequestInput;
};


export type SubscriptionPriceArgs = {
  input: PriceInput;
};


export type SubscriptionRealtimePriceArgs = {
  input: RealtimePriceInput;
};

export type SuccessPayload = {
  readonly __typename: 'SuccessPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly success?: Maybe<Scalars['Boolean']>;
};

/**
 * Give details about an individual transaction.
 * Galoy have a smart routing system which is automatically
 * settling intraledger when both the payer and payee use the same wallet
 * therefore it's possible the transactions is being initiated onchain
 * or with lightning but settled intraledger.
 */
export type Transaction = {
  readonly __typename: 'Transaction';
  readonly createdAt: Scalars['Timestamp'];
  readonly direction: TxDirection;
  readonly id: Scalars['ID'];
  /** From which protocol the payment has been initiated. */
  readonly initiationVia: InitiationVia;
  readonly memo?: Maybe<Scalars['Memo']>;
  /** Amount of the settlement currency sent or received. */
  readonly settlementAmount: Scalars['SignedAmount'];
  /** Wallet currency for transaction. */
  readonly settlementCurrency: WalletCurrency;
  readonly settlementDisplayAmount: Scalars['SignedDisplayMajorAmount'];
  readonly settlementDisplayCurrency: Scalars['DisplayCurrency'];
  readonly settlementDisplayFee: Scalars['SignedDisplayMajorAmount'];
  readonly settlementFee: Scalars['SignedAmount'];
  /** Price in WALLETCURRENCY/SETTLEMENTUNIT at time of settlement. */
  readonly settlementPrice: PriceOfOneSettlementMinorUnitInDisplayMinorUnit;
  /** To which protocol the payment has settled on. */
  readonly settlementVia: SettlementVia;
  readonly status: TxStatus;
};

/** A connection to a list of items. */
export type TransactionConnection = {
  readonly __typename: 'TransactionConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<TransactionEdge>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TransactionEdge = {
  readonly __typename: 'TransactionEdge';
  /** A cursor for use in pagination */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge */
  readonly node: Transaction;
};

export const TxDirection = {
  Receive: 'RECEIVE',
  Send: 'SEND'
} as const;

export type TxDirection = typeof TxDirection[keyof typeof TxDirection];
export const TxNotificationType = {
  IntraLedgerPayment: 'IntraLedgerPayment',
  IntraLedgerReceipt: 'IntraLedgerReceipt',
  LigtningReceipt: 'LigtningReceipt',
  OnchainPayment: 'OnchainPayment',
  OnchainReceipt: 'OnchainReceipt',
  OnchainReceiptPending: 'OnchainReceiptPending'
} as const;

export type TxNotificationType = typeof TxNotificationType[keyof typeof TxNotificationType];
export const TxStatus = {
  Failure: 'FAILURE',
  Pending: 'PENDING',
  Success: 'SUCCESS'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];
export type UpgradePayload = {
  readonly __typename: 'UpgradePayload';
  readonly authToken?: Maybe<Scalars['AuthToken']>;
  readonly errors: ReadonlyArray<Error>;
  readonly success: Scalars['Boolean'];
};

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWallet = Wallet & {
  readonly __typename: 'UsdWallet';
  readonly accountId: Scalars['ID'];
  readonly balance: Scalars['SignedAmount'];
  readonly id: Scalars['ID'];
  readonly invoiceByPaymentHash: Invoice;
  /** A list of all invoices associated with walletIds optionally passed. */
  readonly invoices?: Maybe<InvoiceConnection>;
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars['SignedAmount'];
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  readonly pendingIncomingTransactionsByAddress: ReadonlyArray<Transaction>;
  readonly transactionById: Transaction;
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly transactionsByPaymentHash: ReadonlyArray<Transaction>;
  readonly transactionsByPaymentRequest: ReadonlyArray<Transaction>;
  readonly walletCurrency: WalletCurrency;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletInvoiceByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletPendingIncomingTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionByIdArgs = {
  transactionId: Scalars['ID'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByPaymentRequestArgs = {
  paymentRequest: Scalars['LnPaymentRequest'];
};

export type User = {
  readonly __typename: 'User';
  /**
   * Get single contact details.
   * Can include the transactions associated with the contact.
   * @deprecated will be moved to Accounts
   */
  readonly contactByUsername: UserContact;
  /**
   * Get full list of contacts.
   * Can include the transactions associated with each contact.
   * @deprecated will be moved to account
   */
  readonly contacts: ReadonlyArray<UserContact>;
  readonly createdAt: Scalars['Timestamp'];
  readonly defaultAccount: Account;
  /** Email address */
  readonly email?: Maybe<Email>;
  readonly id: Scalars['ID'];
  /**
   * Preferred language for user.
   * When value is 'default' the intent is to use preferred language from OS settings.
   */
  readonly language: Scalars['Language'];
  /** Phone number with international calling code. */
  readonly phone?: Maybe<Scalars['Phone']>;
  /** Whether TOTP is enabled for this user. */
  readonly totpEnabled: Scalars['Boolean'];
  /**
   * Optional immutable user friendly identifier.
   * @deprecated will be moved to @Handle in Account and Wallet
   */
  readonly username?: Maybe<Scalars['Username']>;
};


export type UserContactByUsernameArgs = {
  username: Scalars['Username'];
};

export type UserContact = {
  readonly __typename: 'UserContact';
  /**
   * Alias the user can set for this contact.
   * Only the user can see the alias attached to their contact.
   */
  readonly alias?: Maybe<Scalars['ContactAlias']>;
  readonly id: Scalars['Username'];
  /** Paginated list of transactions sent to/from this contact. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsCount: Scalars['Int'];
  /** Actual identifier of the contact. */
  readonly username: Scalars['Username'];
};


export type UserContactTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type UserContactUpdateAliasInput = {
  readonly alias: Scalars['ContactAlias'];
  readonly username: Scalars['Username'];
};

export type UserContactUpdateAliasPayload = {
  readonly __typename: 'UserContactUpdateAliasPayload';
  readonly contact?: Maybe<UserContact>;
  readonly errors: ReadonlyArray<Error>;
};

export type UserEmailDeletePayload = {
  readonly __typename: 'UserEmailDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserEmailRegistrationInitiateInput = {
  readonly email: Scalars['EmailAddress'];
};

export type UserEmailRegistrationInitiatePayload = {
  readonly __typename: 'UserEmailRegistrationInitiatePayload';
  readonly emailRegistrationId?: Maybe<Scalars['EmailRegistrationId']>;
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserEmailRegistrationValidateInput = {
  readonly code: Scalars['OneTimeAuthCode'];
  readonly emailRegistrationId: Scalars['EmailRegistrationId'];
};

export type UserEmailRegistrationValidatePayload = {
  readonly __typename: 'UserEmailRegistrationValidatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserLoginInput = {
  readonly code: Scalars['OneTimeAuthCode'];
  readonly phone: Scalars['Phone'];
};

export type UserLoginUpgradeInput = {
  readonly code: Scalars['OneTimeAuthCode'];
  readonly phone: Scalars['Phone'];
};

export type UserLogoutInput = {
  readonly deviceToken: Scalars['String'];
};

export type UserPhoneDeletePayload = {
  readonly __typename: 'UserPhoneDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserPhoneRegistrationInitiateInput = {
  readonly channel?: InputMaybe<PhoneCodeChannelType>;
  readonly phone: Scalars['Phone'];
};

export type UserPhoneRegistrationValidateInput = {
  readonly code: Scalars['OneTimeAuthCode'];
  readonly phone: Scalars['Phone'];
};

export type UserPhoneRegistrationValidatePayload = {
  readonly __typename: 'UserPhoneRegistrationValidatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserTotpDeletePayload = {
  readonly __typename: 'UserTotpDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserTotpRegistrationInitiatePayload = {
  readonly __typename: 'UserTotpRegistrationInitiatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly totpRegistrationId?: Maybe<Scalars['TotpRegistrationId']>;
  readonly totpSecret?: Maybe<Scalars['TotpSecret']>;
};

export type UserTotpRegistrationValidateInput = {
  readonly authToken?: InputMaybe<Scalars['AuthToken']>;
  readonly totpCode: Scalars['TotpCode'];
  readonly totpRegistrationId: Scalars['TotpRegistrationId'];
};

export type UserTotpRegistrationValidatePayload = {
  readonly __typename: 'UserTotpRegistrationValidatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserUpdate = IntraLedgerUpdate | LnUpdate | OnChainUpdate | Price | RealtimePrice;

export type UserUpdateLanguageInput = {
  readonly language: Scalars['Language'];
};

export type UserUpdateLanguagePayload = {
  readonly __typename: 'UserUpdateLanguagePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly user?: Maybe<User>;
};

export type UserUpdateUsernameInput = {
  readonly username: Scalars['Username'];
};

export type UserUpdateUsernamePayload = {
  readonly __typename: 'UserUpdateUsernamePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly user?: Maybe<User>;
};

/** A generic wallet which stores value in one of our supported currencies. */
export type Wallet = {
  readonly accountId: Scalars['ID'];
  readonly balance: Scalars['SignedAmount'];
  readonly id: Scalars['ID'];
  readonly invoiceByPaymentHash: Invoice;
  readonly invoices?: Maybe<InvoiceConnection>;
  readonly pendingIncomingBalance: Scalars['SignedAmount'];
  /**
   * Pending incoming OnChain transactions. When transactions
   * are confirmed they will receive a new id and be found in the transactions
   * list. Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  /**
   * Pending incoming OnChain transactions. When transactions
   * are confirmed they will receive a new id and be found in the transactions
   * list. Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly pendingIncomingTransactionsByAddress: ReadonlyArray<Transaction>;
  readonly transactionById: Transaction;
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactions?: Maybe<TransactionConnection>;
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  /** Returns the transactions that include this paymentHash. This should be a list of size one for a received lightning payment. This can be more that one transaction for a sent lightning payment. */
  readonly transactionsByPaymentHash: ReadonlyArray<Transaction>;
  /** Returns the transactions that include this paymentRequest. */
  readonly transactionsByPaymentRequest: ReadonlyArray<Transaction>;
  readonly walletCurrency: WalletCurrency;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletInvoiceByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletPendingIncomingTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionByIdArgs = {
  transactionId: Scalars['ID'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByPaymentRequestArgs = {
  paymentRequest: Scalars['LnPaymentRequest'];
};

export const WalletCurrency = {
  Btc: 'BTC',
  Usd: 'USD'
} as const;

export type WalletCurrency = typeof WalletCurrency[keyof typeof WalletCurrency];
export type AccountDefaultWalletsQueryVariables = Exact<{
  username: Scalars['Username'];
}>;


export type AccountDefaultWalletsQuery = { readonly __typename: 'Query', readonly accountDefaultWallet: { readonly __typename: 'PublicWallet', readonly id: string, readonly walletCurrency: WalletCurrency } };

export type GetPaginatedTransactionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type GetPaginatedTransactionsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly transactions?: { readonly __typename: 'TransactionConnection', readonly edges?: ReadonlyArray<{ readonly __typename: 'TransactionEdge', readonly cursor: string, readonly node: { readonly __typename: 'Transaction', readonly createdAt: number, readonly direction: TxDirection, readonly id: string, readonly memo?: string | null, readonly settlementAmount: number, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementDisplayFee: string, readonly settlementFee: number, readonly status: TxStatus, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyUsername?: string | null, readonly counterPartyWalletId?: string | null } | { readonly __typename: 'SettlementViaLn', readonly paymentSecret?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly vout?: number | null }, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly currencyUnit: string, readonly formattedAmount: string, readonly offset: number }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyUsername?: string | null, readonly counterPartyWalletId?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string } } }> | null, readonly pageInfo: { readonly __typename: 'PageInfo', readonly endCursor?: string | null, readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null } } | null } } | null };

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null } | null };

export type LnInvoiceCreateOnBehalfOfRecipientMutationVariables = Exact<{
  walletId: Scalars['WalletId'];
  amount: Scalars['SatAmount'];
  descriptionHash: Scalars['Hex32Bytes'];
}>;


export type LnInvoiceCreateOnBehalfOfRecipientMutation = { readonly __typename: 'Mutation', readonly mutationData: { readonly __typename: 'LnInvoicePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly invoice?: { readonly __typename: 'LnInvoice', readonly paymentRequest: string, readonly paymentHash: string } | null } };

export type AccountDefaultWalletQueryVariables = Exact<{
  username: Scalars['Username'];
  walletCurrency: WalletCurrency;
}>;


export type AccountDefaultWalletQuery = { readonly __typename: 'Query', readonly accountDefaultWallet: { readonly __typename: 'PublicWallet', readonly id: string, readonly walletCurrency: WalletCurrency } };

export type LnInvoicePaymentStatusSubscriptionVariables = Exact<{
  input: LnInvoicePaymentStatusInput;
}>;


export type LnInvoicePaymentStatusSubscription = { readonly __typename: 'Subscription', readonly lnInvoicePaymentStatus: { readonly __typename: 'LnInvoicePaymentStatusPayload', readonly status?: InvoicePaymentStatus | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables = Exact<{
  input: LnUsdInvoiceCreateOnBehalfOfRecipientInput;
}>;


export type LnUsdInvoiceCreateOnBehalfOfRecipientMutation = { readonly __typename: 'Mutation', readonly lnUsdInvoiceCreateOnBehalfOfRecipient: { readonly __typename: 'LnInvoicePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly invoice?: { readonly __typename: 'LnInvoice', readonly paymentHash: string, readonly paymentRequest: string, readonly paymentSecret: string, readonly satoshis: number } | null } };

export type LnInvoiceCreateOnBehalfOfRecipientsMutationVariables = Exact<{
  input: LnInvoiceCreateOnBehalfOfRecipientInput;
}>;


export type LnInvoiceCreateOnBehalfOfRecipientsMutation = { readonly __typename: 'Mutation', readonly lnInvoiceCreateOnBehalfOfRecipient: { readonly __typename: 'LnInvoicePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly invoice?: { readonly __typename: 'LnInvoice', readonly paymentHash: string, readonly paymentRequest: string, readonly paymentSecret: string, readonly satoshis: number } | null } };

export type CurrencyListQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrencyListQuery = { readonly __typename: 'Query', readonly currencyList: ReadonlyArray<{ readonly __typename: 'Currency', readonly id: string, readonly flag: string, readonly name: string, readonly symbol: string, readonly fractionDigits: number }> };

export type RealtimePriceWsSubscriptionVariables = Exact<{
  currency: Scalars['DisplayCurrency'];
}>;


export type RealtimePriceWsSubscription = { readonly __typename: 'Subscription', readonly realtimePrice: { readonly __typename: 'RealtimePricePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly realtimePrice?: { readonly __typename: 'RealtimePrice', readonly timestamp: number, readonly denominatorCurrency: string, readonly btcSatPrice: { readonly __typename: 'PriceOfOneSatInMinorUnit', readonly base: number, readonly offset: number }, readonly usdCentPrice: { readonly __typename: 'PriceOfOneUsdCentInMinorUnit', readonly base: number, readonly offset: number } } | null } };

export type RealtimePriceInitialQueryVariables = Exact<{
  currency: Scalars['DisplayCurrency'];
}>;


export type RealtimePriceInitialQuery = { readonly __typename: 'Query', readonly realtimePrice: { readonly __typename: 'RealtimePrice', readonly timestamp: number, readonly denominatorCurrency: string, readonly btcSatPrice: { readonly __typename: 'PriceOfOneSatInMinorUnit', readonly base: number, readonly offset: number }, readonly usdCentPrice: { readonly __typename: 'PriceOfOneUsdCentInMinorUnit', readonly base: number, readonly offset: number } } };

export type PriceSubscriptionVariables = Exact<{
  amount: Scalars['SatAmount'];
  amountCurrencyUnit: ExchangeCurrencyUnit;
  priceCurrencyUnit: ExchangeCurrencyUnit;
}>;


export type PriceSubscription = { readonly __typename: 'Subscription', readonly price: { readonly __typename: 'PricePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly price?: { readonly __typename: 'Price', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string } | null } };


export const AccountDefaultWalletsDocument = gql`
    query accountDefaultWallets($username: Username!) {
  accountDefaultWallet(username: $username) {
    __typename
    id
    walletCurrency
  }
}
    `;

/**
 * __useAccountDefaultWalletsQuery__
 *
 * To run a query within a React component, call `useAccountDefaultWalletsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWalletsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWalletsQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useAccountDefaultWalletsQuery(baseOptions: Apollo.QueryHookOptions<AccountDefaultWalletsQuery, AccountDefaultWalletsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountDefaultWalletsQuery, AccountDefaultWalletsQueryVariables>(AccountDefaultWalletsDocument, options);
      }
export function useAccountDefaultWalletsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountDefaultWalletsQuery, AccountDefaultWalletsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountDefaultWalletsQuery, AccountDefaultWalletsQueryVariables>(AccountDefaultWalletsDocument, options);
        }
export type AccountDefaultWalletsQueryHookResult = ReturnType<typeof useAccountDefaultWalletsQuery>;
export type AccountDefaultWalletsLazyQueryHookResult = ReturnType<typeof useAccountDefaultWalletsLazyQuery>;
export type AccountDefaultWalletsQueryResult = Apollo.QueryResult<AccountDefaultWalletsQuery, AccountDefaultWalletsQueryVariables>;
export const GetPaginatedTransactionsDocument = gql`
    query GetPaginatedTransactions($first: Int, $after: String, $before: String) {
  me {
    id
    defaultAccount {
      transactions(first: $first, after: $after, before: $before) {
        edges {
          cursor
          node {
            createdAt
            direction
            id
            memo
            settlementAmount
            settlementCurrency
            settlementDisplayAmount
            settlementDisplayCurrency
            settlementDisplayFee
            settlementFee
            settlementVia {
              ... on SettlementViaIntraLedger {
                counterPartyUsername
                counterPartyWalletId
              }
              ... on SettlementViaLn {
                paymentSecret
                preImage
              }
              ... on SettlementViaOnChain {
                transactionHash
                vout
              }
            }
            status
            settlementPrice {
              base
              currencyUnit
              formattedAmount
              offset
            }
            initiationVia {
              ... on InitiationViaIntraLedger {
                counterPartyUsername
                counterPartyWalletId
              }
              ... on InitiationViaOnChain {
                address
              }
              ... on InitiationViaLn {
                paymentHash
              }
            }
          }
        }
        pageInfo {
          endCursor
          hasNextPage
          hasPreviousPage
          startCursor
        }
      }
    }
  }
}
    `;

/**
 * __useGetPaginatedTransactionsQuery__
 *
 * To run a query within a React component, call `useGetPaginatedTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPaginatedTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPaginatedTransactionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useGetPaginatedTransactionsQuery(baseOptions?: Apollo.QueryHookOptions<GetPaginatedTransactionsQuery, GetPaginatedTransactionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPaginatedTransactionsQuery, GetPaginatedTransactionsQueryVariables>(GetPaginatedTransactionsDocument, options);
      }
export function useGetPaginatedTransactionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPaginatedTransactionsQuery, GetPaginatedTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPaginatedTransactionsQuery, GetPaginatedTransactionsQueryVariables>(GetPaginatedTransactionsDocument, options);
        }
export type GetPaginatedTransactionsQueryHookResult = ReturnType<typeof useGetPaginatedTransactionsQuery>;
export type GetPaginatedTransactionsLazyQueryHookResult = ReturnType<typeof useGetPaginatedTransactionsLazyQuery>;
export type GetPaginatedTransactionsQueryResult = Apollo.QueryResult<GetPaginatedTransactionsQuery, GetPaginatedTransactionsQueryVariables>;
export const MeDocument = gql`
    query me {
  me {
    id
    username
  }
}
    `;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
      }
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const LnInvoiceCreateOnBehalfOfRecipientDocument = gql`
    mutation lnInvoiceCreateOnBehalfOfRecipient($walletId: WalletId!, $amount: SatAmount!, $descriptionHash: Hex32Bytes!) {
  mutationData: lnInvoiceCreateOnBehalfOfRecipient(
    input: {recipientWalletId: $walletId, amount: $amount, descriptionHash: $descriptionHash}
  ) {
    errors {
      message
    }
    invoice {
      paymentRequest
      paymentHash
    }
  }
}
    `;
export type LnInvoiceCreateOnBehalfOfRecipientMutationFn = Apollo.MutationFunction<LnInvoiceCreateOnBehalfOfRecipientMutation, LnInvoiceCreateOnBehalfOfRecipientMutationVariables>;

/**
 * __useLnInvoiceCreateOnBehalfOfRecipientMutation__
 *
 * To run a mutation, you first call `useLnInvoiceCreateOnBehalfOfRecipientMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceCreateOnBehalfOfRecipientMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceCreateOnBehalfOfRecipientMutation, { data, loading, error }] = useLnInvoiceCreateOnBehalfOfRecipientMutation({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      amount: // value for 'amount'
 *      descriptionHash: // value for 'descriptionHash'
 *   },
 * });
 */
export function useLnInvoiceCreateOnBehalfOfRecipientMutation(baseOptions?: Apollo.MutationHookOptions<LnInvoiceCreateOnBehalfOfRecipientMutation, LnInvoiceCreateOnBehalfOfRecipientMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnInvoiceCreateOnBehalfOfRecipientMutation, LnInvoiceCreateOnBehalfOfRecipientMutationVariables>(LnInvoiceCreateOnBehalfOfRecipientDocument, options);
      }
export type LnInvoiceCreateOnBehalfOfRecipientMutationHookResult = ReturnType<typeof useLnInvoiceCreateOnBehalfOfRecipientMutation>;
export type LnInvoiceCreateOnBehalfOfRecipientMutationResult = Apollo.MutationResult<LnInvoiceCreateOnBehalfOfRecipientMutation>;
export type LnInvoiceCreateOnBehalfOfRecipientMutationOptions = Apollo.BaseMutationOptions<LnInvoiceCreateOnBehalfOfRecipientMutation, LnInvoiceCreateOnBehalfOfRecipientMutationVariables>;
export const AccountDefaultWalletDocument = gql`
    query accountDefaultWallet($username: Username!, $walletCurrency: WalletCurrency!) {
  accountDefaultWallet(username: $username, walletCurrency: $walletCurrency) {
    __typename
    id
    walletCurrency
  }
}
    `;

/**
 * __useAccountDefaultWalletQuery__
 *
 * To run a query within a React component, call `useAccountDefaultWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWalletQuery({
 *   variables: {
 *      username: // value for 'username'
 *      walletCurrency: // value for 'walletCurrency'
 *   },
 * });
 */
export function useAccountDefaultWalletQuery(baseOptions: Apollo.QueryHookOptions<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(AccountDefaultWalletDocument, options);
      }
export function useAccountDefaultWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(AccountDefaultWalletDocument, options);
        }
export type AccountDefaultWalletQueryHookResult = ReturnType<typeof useAccountDefaultWalletQuery>;
export type AccountDefaultWalletLazyQueryHookResult = ReturnType<typeof useAccountDefaultWalletLazyQuery>;
export type AccountDefaultWalletQueryResult = Apollo.QueryResult<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>;
export const LnInvoicePaymentStatusDocument = gql`
    subscription lnInvoicePaymentStatus($input: LnInvoicePaymentStatusInput!) {
  lnInvoicePaymentStatus(input: $input) {
    __typename
    errors {
      message
      __typename
    }
    status
  }
}
    `;

/**
 * __useLnInvoicePaymentStatusSubscription__
 *
 * To run a query within a React component, call `useLnInvoicePaymentStatusSubscription` and pass it any options that fit your needs.
 * When your component renders, `useLnInvoicePaymentStatusSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLnInvoicePaymentStatusSubscription({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoicePaymentStatusSubscription(baseOptions: Apollo.SubscriptionHookOptions<LnInvoicePaymentStatusSubscription, LnInvoicePaymentStatusSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<LnInvoicePaymentStatusSubscription, LnInvoicePaymentStatusSubscriptionVariables>(LnInvoicePaymentStatusDocument, options);
      }
export type LnInvoicePaymentStatusSubscriptionHookResult = ReturnType<typeof useLnInvoicePaymentStatusSubscription>;
export type LnInvoicePaymentStatusSubscriptionResult = Apollo.SubscriptionResult<LnInvoicePaymentStatusSubscription>;
export const LnUsdInvoiceCreateOnBehalfOfRecipientDocument = gql`
    mutation lnUsdInvoiceCreateOnBehalfOfRecipient($input: LnUsdInvoiceCreateOnBehalfOfRecipientInput!) {
  lnUsdInvoiceCreateOnBehalfOfRecipient(input: $input) {
    errors {
      __typename
      message
    }
    invoice {
      __typename
      paymentHash
      paymentRequest
      paymentSecret
      satoshis
    }
    __typename
  }
}
    `;
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationFn = Apollo.MutationFunction<LnUsdInvoiceCreateOnBehalfOfRecipientMutation, LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables>;

/**
 * __useLnUsdInvoiceCreateOnBehalfOfRecipientMutation__
 *
 * To run a mutation, you first call `useLnUsdInvoiceCreateOnBehalfOfRecipientMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnUsdInvoiceCreateOnBehalfOfRecipientMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnUsdInvoiceCreateOnBehalfOfRecipientMutation, { data, loading, error }] = useLnUsdInvoiceCreateOnBehalfOfRecipientMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnUsdInvoiceCreateOnBehalfOfRecipientMutation(baseOptions?: Apollo.MutationHookOptions<LnUsdInvoiceCreateOnBehalfOfRecipientMutation, LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnUsdInvoiceCreateOnBehalfOfRecipientMutation, LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables>(LnUsdInvoiceCreateOnBehalfOfRecipientDocument, options);
      }
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationHookResult = ReturnType<typeof useLnUsdInvoiceCreateOnBehalfOfRecipientMutation>;
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationResult = Apollo.MutationResult<LnUsdInvoiceCreateOnBehalfOfRecipientMutation>;
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationOptions = Apollo.BaseMutationOptions<LnUsdInvoiceCreateOnBehalfOfRecipientMutation, LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables>;
export const LnInvoiceCreateOnBehalfOfRecipientsDocument = gql`
    mutation lnInvoiceCreateOnBehalfOfRecipients($input: LnInvoiceCreateOnBehalfOfRecipientInput!) {
  lnInvoiceCreateOnBehalfOfRecipient(input: $input) {
    errors {
      __typename
      message
    }
    invoice {
      __typename
      paymentHash
      paymentRequest
      paymentSecret
      satoshis
    }
    __typename
  }
}
    `;
export type LnInvoiceCreateOnBehalfOfRecipientsMutationFn = Apollo.MutationFunction<LnInvoiceCreateOnBehalfOfRecipientsMutation, LnInvoiceCreateOnBehalfOfRecipientsMutationVariables>;

/**
 * __useLnInvoiceCreateOnBehalfOfRecipientsMutation__
 *
 * To run a mutation, you first call `useLnInvoiceCreateOnBehalfOfRecipientsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceCreateOnBehalfOfRecipientsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceCreateOnBehalfOfRecipientsMutation, { data, loading, error }] = useLnInvoiceCreateOnBehalfOfRecipientsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoiceCreateOnBehalfOfRecipientsMutation(baseOptions?: Apollo.MutationHookOptions<LnInvoiceCreateOnBehalfOfRecipientsMutation, LnInvoiceCreateOnBehalfOfRecipientsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnInvoiceCreateOnBehalfOfRecipientsMutation, LnInvoiceCreateOnBehalfOfRecipientsMutationVariables>(LnInvoiceCreateOnBehalfOfRecipientsDocument, options);
      }
export type LnInvoiceCreateOnBehalfOfRecipientsMutationHookResult = ReturnType<typeof useLnInvoiceCreateOnBehalfOfRecipientsMutation>;
export type LnInvoiceCreateOnBehalfOfRecipientsMutationResult = Apollo.MutationResult<LnInvoiceCreateOnBehalfOfRecipientsMutation>;
export type LnInvoiceCreateOnBehalfOfRecipientsMutationOptions = Apollo.BaseMutationOptions<LnInvoiceCreateOnBehalfOfRecipientsMutation, LnInvoiceCreateOnBehalfOfRecipientsMutationVariables>;
export const CurrencyListDocument = gql`
    query currencyList {
  currencyList {
    __typename
    id
    flag
    name
    symbol
    fractionDigits
  }
}
    `;

/**
 * __useCurrencyListQuery__
 *
 * To run a query within a React component, call `useCurrencyListQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrencyListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrencyListQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrencyListQuery(baseOptions?: Apollo.QueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrencyListQuery, CurrencyListQueryVariables>(CurrencyListDocument, options);
      }
export function useCurrencyListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrencyListQuery, CurrencyListQueryVariables>(CurrencyListDocument, options);
        }
export type CurrencyListQueryHookResult = ReturnType<typeof useCurrencyListQuery>;
export type CurrencyListLazyQueryHookResult = ReturnType<typeof useCurrencyListLazyQuery>;
export type CurrencyListQueryResult = Apollo.QueryResult<CurrencyListQuery, CurrencyListQueryVariables>;
export const RealtimePriceWsDocument = gql`
    subscription realtimePriceWs($currency: DisplayCurrency!) {
  realtimePrice(input: {currency: $currency}) {
    errors {
      message
    }
    realtimePrice {
      timestamp
      btcSatPrice {
        base
        offset
      }
      usdCentPrice {
        base
        offset
      }
      denominatorCurrency
    }
  }
}
    `;

/**
 * __useRealtimePriceWsSubscription__
 *
 * To run a query within a React component, call `useRealtimePriceWsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useRealtimePriceWsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRealtimePriceWsSubscription({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useRealtimePriceWsSubscription(baseOptions: Apollo.SubscriptionHookOptions<RealtimePriceWsSubscription, RealtimePriceWsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<RealtimePriceWsSubscription, RealtimePriceWsSubscriptionVariables>(RealtimePriceWsDocument, options);
      }
export type RealtimePriceWsSubscriptionHookResult = ReturnType<typeof useRealtimePriceWsSubscription>;
export type RealtimePriceWsSubscriptionResult = Apollo.SubscriptionResult<RealtimePriceWsSubscription>;
export const RealtimePriceInitialDocument = gql`
    query realtimePriceInitial($currency: DisplayCurrency!) {
  realtimePrice(currency: $currency) {
    timestamp
    btcSatPrice {
      base
      offset
    }
    usdCentPrice {
      base
      offset
    }
    denominatorCurrency
  }
}
    `;

/**
 * __useRealtimePriceInitialQuery__
 *
 * To run a query within a React component, call `useRealtimePriceInitialQuery` and pass it any options that fit your needs.
 * When your component renders, `useRealtimePriceInitialQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRealtimePriceInitialQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useRealtimePriceInitialQuery(baseOptions: Apollo.QueryHookOptions<RealtimePriceInitialQuery, RealtimePriceInitialQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RealtimePriceInitialQuery, RealtimePriceInitialQueryVariables>(RealtimePriceInitialDocument, options);
      }
export function useRealtimePriceInitialLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RealtimePriceInitialQuery, RealtimePriceInitialQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RealtimePriceInitialQuery, RealtimePriceInitialQueryVariables>(RealtimePriceInitialDocument, options);
        }
export type RealtimePriceInitialQueryHookResult = ReturnType<typeof useRealtimePriceInitialQuery>;
export type RealtimePriceInitialLazyQueryHookResult = ReturnType<typeof useRealtimePriceInitialLazyQuery>;
export type RealtimePriceInitialQueryResult = Apollo.QueryResult<RealtimePriceInitialQuery, RealtimePriceInitialQueryVariables>;
export const PriceDocument = gql`
    subscription price($amount: SatAmount!, $amountCurrencyUnit: ExchangeCurrencyUnit!, $priceCurrencyUnit: ExchangeCurrencyUnit!) {
  price(
    input: {amount: $amount, amountCurrencyUnit: $amountCurrencyUnit, priceCurrencyUnit: $priceCurrencyUnit}
  ) {
    errors {
      message
    }
    price {
      base
      offset
      currencyUnit
      formattedAmount
    }
  }
}
    `;

/**
 * __usePriceSubscription__
 *
 * To run a query within a React component, call `usePriceSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePriceSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePriceSubscription({
 *   variables: {
 *      amount: // value for 'amount'
 *      amountCurrencyUnit: // value for 'amountCurrencyUnit'
 *      priceCurrencyUnit: // value for 'priceCurrencyUnit'
 *   },
 * });
 */
export function usePriceSubscription(baseOptions: Apollo.SubscriptionHookOptions<PriceSubscription, PriceSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<PriceSubscription, PriceSubscriptionVariables>(PriceDocument, options);
      }
export type PriceSubscriptionHookResult = ReturnType<typeof usePriceSubscription>;
export type PriceSubscriptionResult = Apollo.SubscriptionResult<PriceSubscription>;