// this file is autogenerated by codegen
/* eslint-disable */
import { gql } from "@apollo/client"
import * as Apollo from "@apollo/client"
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** An Opaque Bearer token */
  AuthToken: string
  /** (Positive) Cent amount (1/100 of a dollar) */
  CentAmount: number
  /** An alias name that a user can set for a wallet (with which they have transactions) */
  ContactAlias: string
  /** A CCA2 country code (ex US, FR, etc) */
  CountryCode: string
  /** Display currency of an account */
  DisplayCurrency: string
  /** Email address */
  EmailAddress: string
  /** An id to be passed between registrationInitiate and registrationValidate for confirming email */
  EmailRegistrationId: string
  /** Feedback shared with our user */
  Feedback: string
  /** Hex-encoded string of 32 bytes */
  Hex32Bytes: string
  Language: string
  LnPaymentPreImage: string
  /** BOLT11 lightning invoice payment request with the amount included */
  LnPaymentRequest: string
  LnPaymentSecret: string
  /** Text field in a lightning payment transaction */
  Memo: string
  /** (Positive) amount of minutes */
  Minutes: string
  /** An address for an on-chain bitcoin destination */
  OnChainAddress: string
  OnChainTxHash: string
  /** An authentication code valid for a single use */
  OneTimeAuthCode: string
  PaymentHash: string
  /** Phone number which includes country code */
  Phone: string
  /** Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1 */
  SafeInt: number
  /** (Positive) Satoshi amount */
  SatAmount: number
  /** (Positive) amount of seconds */
  Seconds: number
  /** An amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedAmount: number
  /** A string amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedDisplayMajorAmount: string
  /** (Positive) Number of blocks in which the transaction is expected to be confirmed */
  TargetConfirmations: number
  /** Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch) */
  Timestamp: number
  /** A time-based one-time password */
  TotpCode: string
  /** An id to be passed between set and verify for confirming totp */
  TotpRegistrationId: string
  /** A secret to generate time-based one-time password */
  TotpSecret: string
  /** Unique identifier of a user */
  Username: string
  /** Unique identifier of a wallet */
  WalletId: string
  _FieldSet: string
}

export type Account = {
  readonly csvTransactions: Scalars["String"]
  readonly defaultWalletId: Scalars["WalletId"]
  readonly displayCurrency: Scalars["DisplayCurrency"]
  readonly id: Scalars["ID"]
  readonly level: AccountLevel
  readonly limits: AccountLimits
  readonly realtimePrice: RealtimePrice
  readonly transactions?: Maybe<TransactionConnection>
  readonly wallets: ReadonlyArray<Wallet>
}

export type AccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars["WalletId"]>
}

export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["WalletId"]>>>
}

export type AccountDeletePayload = {
  readonly __typename: "AccountDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly success: Scalars["Boolean"]
}

export const AccountLevel = {
  One: "ONE",
  Two: "TWO",
  Zero: "ZERO",
} as const

export type AccountLevel = (typeof AccountLevel)[keyof typeof AccountLevel]
export type AccountLimit = {
  /** The rolling time interval in seconds that the limits would apply for. */
  readonly interval?: Maybe<Scalars["Seconds"]>
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars["CentAmount"]>
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars["CentAmount"]
}

export type AccountLimits = {
  readonly __typename: "AccountLimits"
  /** Limits for converting between currencies among a account's own wallets. */
  readonly convert: ReadonlyArray<AccountLimit>
  /** Limits for sending to other internal accounts. */
  readonly internalSend: ReadonlyArray<AccountLimit>
  /** Limits for withdrawing to external onchain or lightning destinations. */
  readonly withdrawal: ReadonlyArray<AccountLimit>
}

export type AccountUpdateDefaultWalletIdInput = {
  readonly walletId: Scalars["WalletId"]
}

export type AccountUpdateDefaultWalletIdPayload = {
  readonly __typename: "AccountUpdateDefaultWalletIdPayload"
  readonly account?: Maybe<ConsumerAccount>
  readonly errors: ReadonlyArray<Error>
}

export type AccountUpdateDisplayCurrencyInput = {
  readonly currency: Scalars["DisplayCurrency"]
}

export type AccountUpdateDisplayCurrencyPayload = {
  readonly __typename: "AccountUpdateDisplayCurrencyPayload"
  readonly account?: Maybe<ConsumerAccount>
  readonly errors: ReadonlyArray<Error>
}

export type AuthTokenPayload = {
  readonly __typename: "AuthTokenPayload"
  readonly authToken?: Maybe<Scalars["AuthToken"]>
  readonly errors: ReadonlyArray<Error>
  readonly totpRequired?: Maybe<Scalars["Boolean"]>
}

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWallet = Wallet & {
  readonly __typename: "BTCWallet"
  readonly accountId: Scalars["ID"]
  /** A balance stored in BTC. */
  readonly balance: Scalars["SignedAmount"]
  readonly id: Scalars["ID"]
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars["SignedAmount"]
  /** A list of BTC transactions associated with this wallet. */
  readonly transactions?: Maybe<TransactionConnection>
  readonly transactionsByAddress?: Maybe<TransactionConnection>
  readonly walletCurrency: WalletCurrency
}

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByAddressArgs = {
  address: Scalars["OnChainAddress"]
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export type BuildInformation = {
  readonly __typename: "BuildInformation"
  readonly commitHash?: Maybe<Scalars["String"]>
  readonly helmRevision?: Maybe<Scalars["Int"]>
}

export type CaptchaCreateChallengePayload = {
  readonly __typename: "CaptchaCreateChallengePayload"
  readonly errors: ReadonlyArray<Error>
  readonly result?: Maybe<CaptchaCreateChallengeResult>
}

export type CaptchaCreateChallengeResult = {
  readonly __typename: "CaptchaCreateChallengeResult"
  readonly challengeCode: Scalars["String"]
  readonly failbackMode: Scalars["Boolean"]
  readonly id: Scalars["String"]
  readonly newCaptcha: Scalars["Boolean"]
}

export type CaptchaRequestAuthCodeInput = {
  readonly challengeCode: Scalars["String"]
  readonly channel?: InputMaybe<PhoneCodeChannelType>
  readonly phone: Scalars["Phone"]
  readonly secCode: Scalars["String"]
  readonly validationCode: Scalars["String"]
}

export type CentAmountPayload = {
  readonly __typename: "CentAmountPayload"
  readonly amount?: Maybe<Scalars["CentAmount"]>
  readonly errors: ReadonlyArray<Error>
}

export type ConsumerAccount = Account & {
  readonly __typename: "ConsumerAccount"
  /** return CSV stream, base64 encoded, of the list of transactions in the wallet */
  readonly csvTransactions: Scalars["String"]
  readonly defaultWalletId: Scalars["WalletId"]
  readonly displayCurrency: Scalars["DisplayCurrency"]
  readonly id: Scalars["ID"]
  readonly level: AccountLevel
  readonly limits: AccountLimits
  /** List the quiz questions of the consumer account */
  readonly quiz: ReadonlyArray<Quiz>
  readonly realtimePrice: RealtimePrice
  /** A list of all transactions associated with walletIds optionally passed. */
  readonly transactions?: Maybe<TransactionConnection>
  readonly wallets: ReadonlyArray<Wallet>
}

export type ConsumerAccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars["WalletId"]>
}

export type ConsumerAccountTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["WalletId"]>>>
}

export type Coordinates = {
  readonly __typename: "Coordinates"
  readonly latitude: Scalars["Float"]
  readonly longitude: Scalars["Float"]
}

export type Country = {
  readonly __typename: "Country"
  readonly id: Scalars["CountryCode"]
  readonly supportedAuthChannels: ReadonlyArray<PhoneCodeChannelType>
}

export type Currency = {
  readonly __typename: "Currency"
  readonly flag: Scalars["String"]
  readonly fractionDigits: Scalars["Int"]
  readonly id: Scalars["ID"]
  readonly name: Scalars["String"]
  readonly symbol: Scalars["String"]
}

export type DepositFeesInformation = {
  readonly __typename: "DepositFeesInformation"
  readonly minBankFee: Scalars["String"]
  /** below this amount minBankFee will be charged */
  readonly minBankFeeThreshold: Scalars["String"]
  /** ratio to charge as basis points above minBankFeeThreshold amount */
  readonly ratio: Scalars["String"]
}

export type DeviceNotificationTokenCreateInput = {
  readonly deviceToken: Scalars["String"]
}

export type Email = {
  readonly __typename: "Email"
  readonly address?: Maybe<Scalars["EmailAddress"]>
  readonly verified?: Maybe<Scalars["Boolean"]>
}

export type Error = {
  readonly code?: Maybe<Scalars["String"]>
  readonly message: Scalars["String"]
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars["String"]>>>
}

export const ExchangeCurrencyUnit = {
  Btcsat: "BTCSAT",
  Usdcent: "USDCENT",
} as const

export type ExchangeCurrencyUnit =
  (typeof ExchangeCurrencyUnit)[keyof typeof ExchangeCurrencyUnit]
export type FeedbackSubmitInput = {
  readonly feedback: Scalars["Feedback"]
}

export type FeesInformation = {
  readonly __typename: "FeesInformation"
  readonly deposit: DepositFeesInformation
}

/** Provides global settings for the application which might have an impact for the user. */
export type Globals = {
  readonly __typename: "Globals"
  readonly buildInformation: BuildInformation
  readonly feesInformation: FeesInformation
  /** The domain name for lightning addresses accepted by this Galoy instance */
  readonly lightningAddressDomain: Scalars["String"]
  readonly lightningAddressDomainAliases: ReadonlyArray<Scalars["String"]>
  /** Which network (mainnet, testnet, regtest, signet) this instance is running on. */
  readonly network: Network
  /**
   * A list of public keys for the running lightning nodes.
   * This can be used to know if an invoice belongs to one of our nodes.
   */
  readonly nodesIds: ReadonlyArray<Scalars["String"]>
  /** A list of countries and their supported auth channels */
  readonly supportedCountries: ReadonlyArray<Country>
}

export type GraphQlApplicationError = Error & {
  readonly __typename: "GraphQLApplicationError"
  readonly code?: Maybe<Scalars["String"]>
  readonly message: Scalars["String"]
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars["String"]>>>
}

export type InitiationVia =
  | InitiationViaIntraLedger
  | InitiationViaLn
  | InitiationViaOnChain

export type InitiationViaIntraLedger = {
  readonly __typename: "InitiationViaIntraLedger"
  readonly counterPartyUsername?: Maybe<Scalars["Username"]>
  readonly counterPartyWalletId?: Maybe<Scalars["WalletId"]>
}

export type InitiationViaLn = {
  readonly __typename: "InitiationViaLn"
  readonly paymentHash: Scalars["PaymentHash"]
}

export type InitiationViaOnChain = {
  readonly __typename: "InitiationViaOnChain"
  readonly address: Scalars["OnChainAddress"]
}

export type IntraLedgerPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly recipientWalletId: Scalars["WalletId"]
  /** The wallet ID of the sender. */
  readonly walletId: Scalars["WalletId"]
}

export type IntraLedgerUpdate = {
  readonly __typename: "IntraLedgerUpdate"
  readonly amount: Scalars["SatAmount"]
  readonly displayCurrencyPerSat: Scalars["Float"]
  readonly txNotificationType: TxNotificationType
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars["Float"]
  readonly walletId: Scalars["WalletId"]
}

export type IntraLedgerUsdPaymentSendInput = {
  /** Amount in cents. */
  readonly amount: Scalars["CentAmount"]
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly recipientWalletId: Scalars["WalletId"]
  /** The wallet ID of the sender. */
  readonly walletId: Scalars["WalletId"]
}

export const InvoicePaymentStatus = {
  Expired: "EXPIRED",
  Paid: "PAID",
  Pending: "PENDING",
} as const

export type InvoicePaymentStatus =
  (typeof InvoicePaymentStatus)[keyof typeof InvoicePaymentStatus]
export type LnInvoice = {
  readonly __typename: "LnInvoice"
  readonly paymentHash: Scalars["PaymentHash"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly paymentSecret: Scalars["LnPaymentSecret"]
  readonly satoshis?: Maybe<Scalars["SatAmount"]>
}

export type LnInvoiceCreateInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a BTC wallet belonging to the current account. */
  readonly walletId: Scalars["WalletId"]
}

export type LnInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  readonly descriptionHash?: InputMaybe<Scalars["Hex32Bytes"]>
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a BTC wallet which belongs to any account. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type LnInvoicePayload = {
  readonly __typename: "LnInvoicePayload"
  readonly errors: ReadonlyArray<Error>
  readonly invoice?: Maybe<LnInvoice>
}

export type LnInvoicePaymentInput = {
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  /** Wallet ID with sufficient balance to cover amount of invoice.  Must belong to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnInvoicePaymentStatusInput = {
  readonly paymentRequest: Scalars["LnPaymentRequest"]
}

export type LnInvoicePaymentStatusPayload = {
  readonly __typename: "LnInvoicePaymentStatusPayload"
  readonly errors: ReadonlyArray<Error>
  readonly status?: Maybe<InvoicePaymentStatus>
}

export type LnNoAmountInvoice = {
  readonly __typename: "LnNoAmountInvoice"
  readonly paymentHash: Scalars["PaymentHash"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly paymentSecret: Scalars["LnPaymentSecret"]
}

export type LnNoAmountInvoiceCreateInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** ID for either a USD or BTC wallet belonging to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountInvoiceCreateOnBehalfOfRecipientInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** ID for either a USD or BTC wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnNoAmountInvoiceFeeProbeInput = {
  readonly amount: Scalars["SatAmount"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountInvoicePayload = {
  readonly __typename: "LnNoAmountInvoicePayload"
  readonly errors: ReadonlyArray<Error>
  readonly invoice?: Maybe<LnNoAmountInvoice>
}

export type LnNoAmountInvoicePaymentInput = {
  /** Amount to pay in satoshis. */
  readonly amount: Scalars["SatAmount"]
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountUsdInvoiceFeeProbeInput = {
  readonly amount: Scalars["CentAmount"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountUsdInvoicePaymentInput = {
  /** Amount to pay in USD cents. */
  readonly amount: Scalars["CentAmount"]
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnUpdate = {
  readonly __typename: "LnUpdate"
  readonly paymentHash: Scalars["PaymentHash"]
  readonly status: InvoicePaymentStatus
  readonly walletId: Scalars["WalletId"]
}

export type LnUsdInvoiceCreateInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars["CentAmount"]
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a USD wallet belonging to the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnUsdInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars["CentAmount"]
  readonly descriptionHash?: InputMaybe<Scalars["Hex32Bytes"]>
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnUsdInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type MapInfo = {
  readonly __typename: "MapInfo"
  readonly coordinates: Coordinates
  readonly title: Scalars["String"]
}

export type MapMarker = {
  readonly __typename: "MapMarker"
  readonly mapInfo: MapInfo
  readonly username?: Maybe<Scalars["Username"]>
}

export type MobileVersions = {
  readonly __typename: "MobileVersions"
  readonly currentSupported: Scalars["Int"]
  readonly minSupported: Scalars["Int"]
  readonly platform: Scalars["String"]
}

export type Mutation = {
  readonly __typename: "Mutation"
  readonly accountDelete: AccountDeletePayload
  readonly accountUpdateDefaultWalletId: AccountUpdateDefaultWalletIdPayload
  readonly accountUpdateDisplayCurrency: AccountUpdateDisplayCurrencyPayload
  readonly captchaCreateChallenge: CaptchaCreateChallengePayload
  readonly captchaRequestAuthCode: SuccessPayload
  readonly deviceNotificationTokenCreate: SuccessPayload
  readonly feedbackSubmit: SuccessPayload
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerPaymentSend: PaymentSendPayload
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerUsdPaymentSend: PaymentSendPayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreate: LnInvoicePayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload
  readonly lnInvoiceFeeProbe: SatAmountPayload
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet can be USD or BTC and must have sufficient balance to cover amount in lightning invoice.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnInvoicePaymentSend: PaymentSendPayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreate: LnNoAmountInvoicePayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreateOnBehalfOfRecipient: LnNoAmountInvoicePayload
  readonly lnNoAmountInvoiceFeeProbe: SatAmountPayload
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be BTC and must have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountInvoicePaymentSend: PaymentSendPayload
  readonly lnNoAmountUsdInvoiceFeeProbe: CentAmountPayload
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be USD and have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountUsdInvoicePaymentSend: PaymentSendPayload
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   * associated with the amount).
   */
  readonly lnUsdInvoiceCreate: LnInvoicePayload
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload
  readonly lnUsdInvoiceFeeProbe: SatAmountPayload
  readonly onChainAddressCreate: OnChainAddressPayload
  readonly onChainAddressCurrent: OnChainAddressPayload
  readonly onChainPaymentSend: PaymentSendPayload
  readonly onChainPaymentSendAll: PaymentSendPayload
  readonly onChainUsdPaymentSend: PaymentSendPayload
  readonly onChainUsdPaymentSendAsBtcDenominated: PaymentSendPayload
  readonly quizCompleted: QuizCompletedPayload
  /** @deprecated will be moved to AccountContact */
  readonly userContactUpdateAlias: UserContactUpdateAliasPayload
  readonly userEmailDelete: UserEmailDeletePayload
  readonly userEmailRegistrationInitiate: UserEmailRegistrationInitiatePayload
  readonly userEmailRegistrationValidate: UserEmailRegistrationValidatePayload
  readonly userLogin: AuthTokenPayload
  readonly userLoginUpgrade: UpgradePayload
  readonly userLogout: SuccessPayload
  readonly userPhoneDelete: UserPhoneDeletePayload
  readonly userPhoneRegistrationInitiate: SuccessPayload
  readonly userPhoneRegistrationValidate: UserPhoneRegistrationValidatePayload
  /** @deprecated Use QuizCompletedMutation instead */
  readonly userQuizQuestionUpdateCompleted: UserQuizQuestionUpdateCompletedPayload
  readonly userRequestAuthCode: SuccessPayload
  readonly userTotpDelete: UserTotpDeletePayload
  readonly userTotpRegistrationInitiate: UserTotpRegistrationInitiatePayload
  readonly userTotpRegistrationValidate: UserTotpRegistrationValidatePayload
  readonly userUpdateLanguage: UserUpdateLanguagePayload
  /** @deprecated Username will be moved to @Handle in Accounts. Also SetUsername naming should be used instead of UpdateUsername to reflect the idempotency of Handles */
  readonly userUpdateUsername: UserUpdateUsernamePayload
}

export type MutationAccountUpdateDefaultWalletIdArgs = {
  input: AccountUpdateDefaultWalletIdInput
}

export type MutationAccountUpdateDisplayCurrencyArgs = {
  input: AccountUpdateDisplayCurrencyInput
}

export type MutationCaptchaRequestAuthCodeArgs = {
  input: CaptchaRequestAuthCodeInput
}

export type MutationDeviceNotificationTokenCreateArgs = {
  input: DeviceNotificationTokenCreateInput
}

export type MutationFeedbackSubmitArgs = {
  input: FeedbackSubmitInput
}

export type MutationIntraLedgerPaymentSendArgs = {
  input: IntraLedgerPaymentSendInput
}

export type MutationIntraLedgerUsdPaymentSendArgs = {
  input: IntraLedgerUsdPaymentSendInput
}

export type MutationLnInvoiceCreateArgs = {
  input: LnInvoiceCreateInput
}

export type MutationLnInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnInvoiceCreateOnBehalfOfRecipientInput
}

export type MutationLnInvoiceFeeProbeArgs = {
  input: LnInvoiceFeeProbeInput
}

export type MutationLnInvoicePaymentSendArgs = {
  input: LnInvoicePaymentInput
}

export type MutationLnNoAmountInvoiceCreateArgs = {
  input: LnNoAmountInvoiceCreateInput
}

export type MutationLnNoAmountInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput
}

export type MutationLnNoAmountInvoiceFeeProbeArgs = {
  input: LnNoAmountInvoiceFeeProbeInput
}

export type MutationLnNoAmountInvoicePaymentSendArgs = {
  input: LnNoAmountInvoicePaymentInput
}

export type MutationLnNoAmountUsdInvoiceFeeProbeArgs = {
  input: LnNoAmountUsdInvoiceFeeProbeInput
}

export type MutationLnNoAmountUsdInvoicePaymentSendArgs = {
  input: LnNoAmountUsdInvoicePaymentInput
}

export type MutationLnUsdInvoiceCreateArgs = {
  input: LnUsdInvoiceCreateInput
}

export type MutationLnUsdInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceCreateOnBehalfOfRecipientInput
}

export type MutationLnUsdInvoiceFeeProbeArgs = {
  input: LnUsdInvoiceFeeProbeInput
}

export type MutationOnChainAddressCreateArgs = {
  input: OnChainAddressCreateInput
}

export type MutationOnChainAddressCurrentArgs = {
  input: OnChainAddressCurrentInput
}

export type MutationOnChainPaymentSendArgs = {
  input: OnChainPaymentSendInput
}

export type MutationOnChainPaymentSendAllArgs = {
  input: OnChainPaymentSendAllInput
}

export type MutationOnChainUsdPaymentSendArgs = {
  input: OnChainUsdPaymentSendInput
}

export type MutationOnChainUsdPaymentSendAsBtcDenominatedArgs = {
  input: OnChainUsdPaymentSendAsBtcDenominatedInput
}

export type MutationQuizCompletedArgs = {
  input: QuizCompletedInput
}

export type MutationUserContactUpdateAliasArgs = {
  input: UserContactUpdateAliasInput
}

export type MutationUserEmailRegistrationInitiateArgs = {
  input: UserEmailRegistrationInitiateInput
}

export type MutationUserEmailRegistrationValidateArgs = {
  input: UserEmailRegistrationValidateInput
}

export type MutationUserLoginArgs = {
  input: UserLoginInput
}

export type MutationUserLoginUpgradeArgs = {
  input: UserLoginUpgradeInput
}

export type MutationUserLogoutArgs = {
  input: UserLogoutInput
}

export type MutationUserPhoneRegistrationInitiateArgs = {
  input: UserPhoneRegistrationInitiateInput
}

export type MutationUserPhoneRegistrationValidateArgs = {
  input: UserPhoneRegistrationValidateInput
}

export type MutationUserQuizQuestionUpdateCompletedArgs = {
  input: UserQuizQuestionUpdateCompletedInput
}

export type MutationUserRequestAuthCodeArgs = {
  input: UserRequestAuthCodeInput
}

export type MutationUserTotpDeleteArgs = {
  input: UserTotpDeleteInput
}

export type MutationUserTotpRegistrationInitiateArgs = {
  input: UserTotpRegistrationInitiateInput
}

export type MutationUserTotpRegistrationValidateArgs = {
  input: UserTotpRegistrationValidateInput
}

export type MutationUserUpdateLanguageArgs = {
  input: UserUpdateLanguageInput
}

export type MutationUserUpdateUsernameArgs = {
  input: UserUpdateUsernameInput
}

export type MyUpdatesPayload = {
  readonly __typename: "MyUpdatesPayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
  readonly update?: Maybe<UserUpdate>
}

export const Network = {
  Mainnet: "mainnet",
  Regtest: "regtest",
  Signet: "signet",
  Testnet: "testnet",
} as const

export type Network = (typeof Network)[keyof typeof Network]
export type OnChainAddressCreateInput = {
  readonly walletId: Scalars["WalletId"]
}

export type OnChainAddressCurrentInput = {
  readonly walletId: Scalars["WalletId"]
}

export type OnChainAddressPayload = {
  readonly __typename: "OnChainAddressPayload"
  readonly address?: Maybe<Scalars["OnChainAddress"]>
  readonly errors: ReadonlyArray<Error>
}

export type OnChainPaymentSendAllInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  /** @deprecated Ignored - will be replaced */
  readonly targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainPaymentSendInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly amount: Scalars["SatAmount"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  /** @deprecated Ignored - will be replaced */
  readonly targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainTxFee = {
  readonly __typename: "OnChainTxFee"
  readonly amount: Scalars["SatAmount"]
  /** @deprecated Ignored - will be removed */
  readonly targetConfirmations: Scalars["TargetConfirmations"]
}

export type OnChainUpdate = {
  readonly __typename: "OnChainUpdate"
  readonly amount: Scalars["SatAmount"]
  readonly displayCurrencyPerSat: Scalars["Float"]
  readonly txHash: Scalars["OnChainTxHash"]
  readonly txNotificationType: TxNotificationType
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars["Float"]
  readonly walletId: Scalars["WalletId"]
}

export type OnChainUsdPaymentSendAsBtcDenominatedInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly amount: Scalars["SatAmount"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  /** @deprecated Ignored - will be replaced */
  readonly targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainUsdPaymentSendInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly amount: Scalars["CentAmount"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  /** @deprecated Ignored - will be replaced */
  readonly targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainUsdTxFee = {
  readonly __typename: "OnChainUsdTxFee"
  readonly amount: Scalars["CentAmount"]
  /** @deprecated Ignored - will be removed */
  readonly targetConfirmations: Scalars["TargetConfirmations"]
}

export type OneDayAccountLimit = AccountLimit & {
  readonly __typename: "OneDayAccountLimit"
  /** The rolling time interval value in seconds for the current 24 hour period. */
  readonly interval?: Maybe<Scalars["Seconds"]>
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars["CentAmount"]>
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars["CentAmount"]
}

/** Information about pagination in a connection. */
export type PageInfo = {
  readonly __typename: "PageInfo"
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars["String"]>
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars["Boolean"]
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars["Boolean"]
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars["String"]>
}

export type PaymentSendPayload = {
  readonly __typename: "PaymentSendPayload"
  readonly errors: ReadonlyArray<Error>
  readonly status?: Maybe<PaymentSendResult>
}

export const PaymentSendResult = {
  AlreadyPaid: "ALREADY_PAID",
  Failure: "FAILURE",
  Pending: "PENDING",
  Success: "SUCCESS",
} as const

export type PaymentSendResult = (typeof PaymentSendResult)[keyof typeof PaymentSendResult]
export const PayoutSpeed = {
  Fast: "FAST",
} as const

export type PayoutSpeed = (typeof PayoutSpeed)[keyof typeof PayoutSpeed]
export const PhoneCodeChannelType = {
  Sms: "SMS",
  Whatsapp: "WHATSAPP",
} as const

export type PhoneCodeChannelType =
  (typeof PhoneCodeChannelType)[keyof typeof PhoneCodeChannelType]
/** Price amount expressed in base/offset. To calculate, use: `base / 10^offset` */
export type Price = {
  readonly __typename: "Price"
  readonly base: Scalars["SafeInt"]
  readonly currencyUnit: Scalars["String"]
  readonly formattedAmount: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** The range for the X axis in the BTC price graph */
export const PriceGraphRange = {
  FiveYears: "FIVE_YEARS",
  OneDay: "ONE_DAY",
  OneMonth: "ONE_MONTH",
  OneWeek: "ONE_WEEK",
  OneYear: "ONE_YEAR",
} as const

export type PriceGraphRange = (typeof PriceGraphRange)[keyof typeof PriceGraphRange]
export type PriceInput = {
  readonly amount: Scalars["SatAmount"]
  readonly amountCurrencyUnit: ExchangeCurrencyUnit
  readonly priceCurrencyUnit: ExchangeCurrencyUnit
}

export type PriceInterface = {
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** Price of 1 sat in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSatInMinorUnit = PriceInterface & {
  readonly __typename: "PriceOfOneSatInMinorUnit"
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** Price of 1 sat or 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSettlementMinorUnitInDisplayMinorUnit = PriceInterface & {
  readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  /** @deprecated Deprecated please use `base / 10^offset` */
  readonly formattedAmount: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** Price of 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneUsdCentInMinorUnit = PriceInterface & {
  readonly __typename: "PriceOfOneUsdCentInMinorUnit"
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  readonly offset: Scalars["Int"]
}

export type PricePayload = {
  readonly __typename: "PricePayload"
  readonly errors: ReadonlyArray<Error>
  readonly price?: Maybe<Price>
}

export type PricePoint = {
  readonly __typename: "PricePoint"
  readonly price: Price
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars["Timestamp"]
}

/** A public view of a generic wallet which stores value in one of our supported currencies. */
export type PublicWallet = {
  readonly __typename: "PublicWallet"
  readonly id: Scalars["ID"]
  readonly walletCurrency: WalletCurrency
}

export type Query = {
  readonly __typename: "Query"
  readonly accountDefaultWallet: PublicWallet
  /** @deprecated Deprecated in favor of realtimePrice */
  readonly btcPrice?: Maybe<Price>
  readonly btcPriceList?: Maybe<ReadonlyArray<Maybe<PricePoint>>>
  readonly businessMapMarkers?: Maybe<ReadonlyArray<Maybe<MapMarker>>>
  readonly currencyList: ReadonlyArray<Currency>
  readonly globals?: Maybe<Globals>
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload
  readonly me?: Maybe<User>
  readonly mobileVersions?: Maybe<ReadonlyArray<Maybe<MobileVersions>>>
  readonly onChainTxFee: OnChainTxFee
  readonly onChainUsdTxFee: OnChainUsdTxFee
  readonly onChainUsdTxFeeAsBtcDenominated: OnChainUsdTxFee
  /** @deprecated TODO: remove. we don't need a non authenticated version of this query. the users can only do the query while authenticated */
  readonly quizQuestions?: Maybe<ReadonlyArray<Maybe<QuizQuestion>>>
  /** Returns 1 Sat and 1 Usd Cent price for the given currency */
  readonly realtimePrice: RealtimePrice
  /** @deprecated will be migrated to AccountDefaultWalletId */
  readonly userDefaultWalletId: Scalars["WalletId"]
  readonly usernameAvailable?: Maybe<Scalars["Boolean"]>
}

export type QueryAccountDefaultWalletArgs = {
  username: Scalars["Username"]
  walletCurrency?: InputMaybe<WalletCurrency>
}

export type QueryBtcPriceArgs = {
  currency?: Scalars["DisplayCurrency"]
}

export type QueryBtcPriceListArgs = {
  range: PriceGraphRange
}

export type QueryLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput
}

export type QueryOnChainTxFeeArgs = {
  address: Scalars["OnChainAddress"]
  amount: Scalars["SatAmount"]
  speed?: InputMaybe<PayoutSpeed>
  targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  walletId: Scalars["WalletId"]
}

export type QueryOnChainUsdTxFeeArgs = {
  address: Scalars["OnChainAddress"]
  amount: Scalars["CentAmount"]
  speed?: InputMaybe<PayoutSpeed>
  targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  walletId: Scalars["WalletId"]
}

export type QueryOnChainUsdTxFeeAsBtcDenominatedArgs = {
  address: Scalars["OnChainAddress"]
  amount: Scalars["SatAmount"]
  speed?: InputMaybe<PayoutSpeed>
  targetConfirmations?: InputMaybe<Scalars["TargetConfirmations"]>
  walletId: Scalars["WalletId"]
}

export type QueryRealtimePriceArgs = {
  currency?: InputMaybe<Scalars["DisplayCurrency"]>
}

export type QueryUserDefaultWalletIdArgs = {
  username: Scalars["Username"]
}

export type QueryUsernameAvailableArgs = {
  username: Scalars["Username"]
}

export type Quiz = {
  readonly __typename: "Quiz"
  /** The reward in Satoshis for the quiz question */
  readonly amount: Scalars["SatAmount"]
  readonly completed: Scalars["Boolean"]
  readonly id: Scalars["ID"]
}

export type QuizCompletedInput = {
  readonly id: Scalars["ID"]
}

export type QuizCompletedPayload = {
  readonly __typename: "QuizCompletedPayload"
  readonly errors: ReadonlyArray<Error>
  readonly quiz?: Maybe<Quiz>
}

export type QuizQuestion = {
  readonly __typename: "QuizQuestion"
  /** The earn reward in Satoshis for the quiz question */
  readonly earnAmount: Scalars["SatAmount"]
  readonly id: Scalars["ID"]
}

export type RealtimePrice = {
  readonly __typename: "RealtimePrice"
  readonly btcSatPrice: PriceOfOneSatInMinorUnit
  readonly denominatorCurrency: Scalars["DisplayCurrency"]
  readonly id: Scalars["ID"]
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars["Timestamp"]
  readonly usdCentPrice: PriceOfOneUsdCentInMinorUnit
}

export type RealtimePriceInput = {
  readonly currency?: InputMaybe<Scalars["DisplayCurrency"]>
}

export type RealtimePricePayload = {
  readonly __typename: "RealtimePricePayload"
  readonly errors: ReadonlyArray<Error>
  readonly realtimePrice?: Maybe<RealtimePrice>
}

export type SatAmountPayload = {
  readonly __typename: "SatAmountPayload"
  readonly amount?: Maybe<Scalars["SatAmount"]>
  readonly errors: ReadonlyArray<Error>
}

export type SettlementVia =
  | SettlementViaIntraLedger
  | SettlementViaLn
  | SettlementViaOnChain

export type SettlementViaIntraLedger = {
  readonly __typename: "SettlementViaIntraLedger"
  /** Settlement destination: Could be null if the payee does not have a username */
  readonly counterPartyUsername?: Maybe<Scalars["Username"]>
  readonly counterPartyWalletId?: Maybe<Scalars["WalletId"]>
}

export type SettlementViaLn = {
  readonly __typename: "SettlementViaLn"
  /** @deprecated Shifting property to 'preImage' to improve granularity of the LnPaymentSecret type */
  readonly paymentSecret?: Maybe<Scalars["LnPaymentSecret"]>
  readonly preImage?: Maybe<Scalars["LnPaymentPreImage"]>
}

export type SettlementViaOnChain = {
  readonly __typename: "SettlementViaOnChain"
  readonly transactionHash?: Maybe<Scalars["OnChainTxHash"]>
  readonly vout?: Maybe<Scalars["Int"]>
}

export type Subscription = {
  readonly __typename: "Subscription"
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload
  readonly myUpdates: MyUpdatesPayload
  readonly price: PricePayload
  /** Returns the price of 1 satoshi */
  readonly realtimePrice: RealtimePricePayload
}

export type SubscriptionLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput
}

export type SubscriptionPriceArgs = {
  input: PriceInput
}

export type SubscriptionRealtimePriceArgs = {
  input: RealtimePriceInput
}

export type SuccessPayload = {
  readonly __typename: "SuccessPayload"
  readonly errors: ReadonlyArray<Error>
  readonly success?: Maybe<Scalars["Boolean"]>
}

/**
 * Give details about an individual transaction.
 * Galoy have a smart routing system which is automatically
 * settling intraledger when both the payer and payee use the same wallet
 * therefore it's possible the transactions is being initiated onchain
 * or with lightning but settled intraledger.
 */
export type Transaction = {
  readonly __typename: "Transaction"
  readonly createdAt: Scalars["Timestamp"]
  readonly direction: TxDirection
  readonly id: Scalars["ID"]
  /** From which protocol the payment has been initiated. */
  readonly initiationVia: InitiationVia
  readonly memo?: Maybe<Scalars["Memo"]>
  /** Amount of the settlement currency sent or received. */
  readonly settlementAmount: Scalars["SignedAmount"]
  /** Wallet currency for transaction. */
  readonly settlementCurrency: WalletCurrency
  readonly settlementDisplayAmount: Scalars["SignedDisplayMajorAmount"]
  readonly settlementDisplayCurrency: Scalars["DisplayCurrency"]
  readonly settlementDisplayFee: Scalars["SignedDisplayMajorAmount"]
  readonly settlementFee: Scalars["SignedAmount"]
  /** Price in WALLETCURRENCY/SETTLEMENTUNIT at time of settlement. */
  readonly settlementPrice: PriceOfOneSettlementMinorUnitInDisplayMinorUnit
  /** To which protocol the payment has settled on. */
  readonly settlementVia: SettlementVia
  readonly status: TxStatus
}

/** A connection to a list of items. */
export type TransactionConnection = {
  readonly __typename: "TransactionConnection"
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<TransactionEdge>>
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo
}

/** An edge in a connection. */
export type TransactionEdge = {
  readonly __typename: "TransactionEdge"
  /** A cursor for use in pagination */
  readonly cursor: Scalars["String"]
  /** The item at the end of the edge */
  readonly node: Transaction
}

export const TxDirection = {
  Receive: "RECEIVE",
  Send: "SEND",
} as const

export type TxDirection = (typeof TxDirection)[keyof typeof TxDirection]
export const TxNotificationType = {
  IntraLedgerPayment: "IntraLedgerPayment",
  IntraLedgerReceipt: "IntraLedgerReceipt",
  LnInvoicePaid: "LnInvoicePaid",
  OnchainPayment: "OnchainPayment",
  OnchainReceipt: "OnchainReceipt",
  OnchainReceiptPending: "OnchainReceiptPending",
} as const

export type TxNotificationType =
  (typeof TxNotificationType)[keyof typeof TxNotificationType]
export const TxStatus = {
  Failure: "FAILURE",
  Pending: "PENDING",
  Success: "SUCCESS",
} as const

export type TxStatus = (typeof TxStatus)[keyof typeof TxStatus]
export type UpgradePayload = {
  readonly __typename: "UpgradePayload"
  readonly authToken?: Maybe<Scalars["AuthToken"]>
  readonly errors: ReadonlyArray<Error>
  readonly success: Scalars["Boolean"]
}

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWallet = Wallet & {
  readonly __typename: "UsdWallet"
  readonly accountId: Scalars["ID"]
  readonly balance: Scalars["SignedAmount"]
  readonly id: Scalars["ID"]
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars["SignedAmount"]
  readonly transactions?: Maybe<TransactionConnection>
  readonly transactionsByAddress?: Maybe<TransactionConnection>
  readonly walletCurrency: WalletCurrency
}

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByAddressArgs = {
  address: Scalars["OnChainAddress"]
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export type User = {
  readonly __typename: "User"
  /**
   * Get single contact details.
   * Can include the transactions associated with the contact.
   * @deprecated will be moved to Accounts
   */
  readonly contactByUsername: UserContact
  /**
   * Get full list of contacts.
   * Can include the transactions associated with each contact.
   * @deprecated will be moved to account
   */
  readonly contacts: ReadonlyArray<UserContact>
  readonly createdAt: Scalars["Timestamp"]
  readonly defaultAccount: Account
  /** Email address */
  readonly email?: Maybe<Email>
  readonly id: Scalars["ID"]
  /**
   * Preferred language for user.
   * When value is 'default' the intent is to use preferred language from OS settings.
   */
  readonly language: Scalars["Language"]
  /** Phone number with international calling code. */
  readonly phone?: Maybe<Scalars["Phone"]>
  /**
   * List the quiz questions the user may have completed.
   * @deprecated use Quiz from Account instead
   */
  readonly quizQuestions: ReadonlyArray<UserQuizQuestion>
  /** Whether TOTP is enabled for this user. */
  readonly totpEnabled: Scalars["Boolean"]
  /**
   * Optional immutable user friendly identifier.
   * @deprecated will be moved to @Handle in Account and Wallet
   */
  readonly username?: Maybe<Scalars["Username"]>
}

export type UserContactByUsernameArgs = {
  username: Scalars["Username"]
}

export type UserContact = {
  readonly __typename: "UserContact"
  /**
   * Alias the user can set for this contact.
   * Only the user can see the alias attached to their contact.
   */
  readonly alias?: Maybe<Scalars["ContactAlias"]>
  readonly id: Scalars["Username"]
  /** Paginated list of transactions sent to/from this contact. */
  readonly transactions?: Maybe<TransactionConnection>
  readonly transactionsCount: Scalars["Int"]
  /** Actual identifier of the contact. */
  readonly username: Scalars["Username"]
}

export type UserContactTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export type UserContactUpdateAliasInput = {
  readonly alias: Scalars["ContactAlias"]
  readonly username: Scalars["Username"]
}

export type UserContactUpdateAliasPayload = {
  readonly __typename: "UserContactUpdateAliasPayload"
  readonly contact?: Maybe<UserContact>
  readonly errors: ReadonlyArray<Error>
}

export type UserEmailDeletePayload = {
  readonly __typename: "UserEmailDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserEmailRegistrationInitiateInput = {
  readonly email: Scalars["EmailAddress"]
}

export type UserEmailRegistrationInitiatePayload = {
  readonly __typename: "UserEmailRegistrationInitiatePayload"
  readonly emailRegistrationId?: Maybe<Scalars["EmailRegistrationId"]>
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserEmailRegistrationValidateInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly emailRegistrationId: Scalars["EmailRegistrationId"]
}

export type UserEmailRegistrationValidatePayload = {
  readonly __typename: "UserEmailRegistrationValidatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserLoginInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly phone: Scalars["Phone"]
}

export type UserLoginUpgradeInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly phone: Scalars["Phone"]
}

export type UserLogoutInput = {
  readonly authToken: Scalars["AuthToken"]
}

export type UserPhoneDeletePayload = {
  readonly __typename: "UserPhoneDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserPhoneRegistrationInitiateInput = {
  readonly channel?: InputMaybe<PhoneCodeChannelType>
  readonly phone: Scalars["Phone"]
}

export type UserPhoneRegistrationValidateInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly phone: Scalars["Phone"]
}

export type UserPhoneRegistrationValidatePayload = {
  readonly __typename: "UserPhoneRegistrationValidatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserQuizQuestion = {
  readonly __typename: "UserQuizQuestion"
  readonly completed: Scalars["Boolean"]
  readonly question: QuizQuestion
}

export type UserQuizQuestionUpdateCompletedInput = {
  readonly id: Scalars["ID"]
}

export type UserQuizQuestionUpdateCompletedPayload = {
  readonly __typename: "UserQuizQuestionUpdateCompletedPayload"
  readonly errors: ReadonlyArray<Error>
  readonly userQuizQuestion?: Maybe<UserQuizQuestion>
}

export type UserRequestAuthCodeInput = {
  readonly channel?: InputMaybe<PhoneCodeChannelType>
  readonly phone: Scalars["Phone"]
}

export type UserTotpDeleteInput = {
  readonly authToken: Scalars["AuthToken"]
}

export type UserTotpDeletePayload = {
  readonly __typename: "UserTotpDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserTotpRegistrationInitiateInput = {
  readonly authToken: Scalars["AuthToken"]
}

export type UserTotpRegistrationInitiatePayload = {
  readonly __typename: "UserTotpRegistrationInitiatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly totpRegistrationId?: Maybe<Scalars["TotpRegistrationId"]>
  readonly totpSecret?: Maybe<Scalars["TotpSecret"]>
}

export type UserTotpRegistrationValidateInput = {
  readonly authToken: Scalars["AuthToken"]
  readonly totpCode: Scalars["TotpCode"]
  readonly totpRegistrationId: Scalars["TotpRegistrationId"]
}

export type UserTotpRegistrationValidatePayload = {
  readonly __typename: "UserTotpRegistrationValidatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserUpdate =
  | IntraLedgerUpdate
  | LnUpdate
  | OnChainUpdate
  | Price
  | RealtimePrice

export type UserUpdateLanguageInput = {
  readonly language: Scalars["Language"]
}

export type UserUpdateLanguagePayload = {
  readonly __typename: "UserUpdateLanguagePayload"
  readonly errors: ReadonlyArray<Error>
  readonly user?: Maybe<User>
}

export type UserUpdateUsernameInput = {
  readonly username: Scalars["Username"]
}

export type UserUpdateUsernamePayload = {
  readonly __typename: "UserUpdateUsernamePayload"
  readonly errors: ReadonlyArray<Error>
  readonly user?: Maybe<User>
}

/** A generic wallet which stores value in one of our supported currencies. */
export type Wallet = {
  readonly accountId: Scalars["ID"]
  readonly balance: Scalars["SignedAmount"]
  readonly id: Scalars["ID"]
  readonly pendingIncomingBalance: Scalars["SignedAmount"]
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactions?: Maybe<TransactionConnection>
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactionsByAddress?: Maybe<TransactionConnection>
  readonly walletCurrency: WalletCurrency
}

/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByAddressArgs = {
  address: Scalars["OnChainAddress"]
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export const WalletCurrency = {
  Btc: "BTC",
  Usd: "USD",
} as const

export type WalletCurrency = (typeof WalletCurrency)[keyof typeof WalletCurrency]
export type LnInvoicePaymentStatusSubscriptionVariables = Exact<{
  input: LnInvoicePaymentStatusInput
}>

export type LnInvoicePaymentStatusSubscription = {
  readonly __typename: "Subscription"
  readonly lnInvoicePaymentStatus: {
    readonly __typename: "LnInvoicePaymentStatusPayload"
    readonly status?: InvoicePaymentStatus | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationVariables = Exact<{
  walletId: Scalars["WalletId"]
}>

export type LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation = {
  readonly __typename: "Mutation"
  readonly mutationData: {
    readonly __typename: "LnNoAmountInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnNoAmountInvoice"
      readonly paymentRequest: string
    } | null
  }
}

export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables = Exact<{
  input: LnUsdInvoiceCreateOnBehalfOfRecipientInput
}>

export type LnUsdInvoiceCreateOnBehalfOfRecipientMutation = {
  readonly __typename: "Mutation"
  readonly lnUsdInvoiceCreateOnBehalfOfRecipient: {
    readonly __typename: "LnInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnInvoice"
      readonly paymentHash: string
      readonly paymentRequest: string
      readonly paymentSecret: string
      readonly satoshis?: number | null
    } | null
  }
}

export type LnInvoiceCreateOnBehalfOfRecipientsMutationVariables = Exact<{
  input: LnInvoiceCreateOnBehalfOfRecipientInput
}>

export type LnInvoiceCreateOnBehalfOfRecipientsMutation = {
  readonly __typename: "Mutation"
  readonly lnInvoiceCreateOnBehalfOfRecipient: {
    readonly __typename: "LnInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnInvoice"
      readonly paymentHash: string
      readonly paymentRequest: string
      readonly paymentSecret: string
      readonly satoshis?: number | null
    } | null
  }
}

export type CurrencyListQueryVariables = Exact<{ [key: string]: never }>

export type CurrencyListQuery = {
  readonly __typename: "Query"
  readonly currencyList: ReadonlyArray<{
    readonly __typename: "Currency"
    readonly id: string
    readonly flag: string
    readonly name: string
    readonly symbol: string
    readonly fractionDigits: number
  }>
}

export type RealtimePriceWsSubscriptionVariables = Exact<{
  currency: Scalars["DisplayCurrency"]
}>

export type RealtimePriceWsSubscription = {
  readonly __typename: "Subscription"
  readonly realtimePrice: {
    readonly __typename: "RealtimePricePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly realtimePrice?: {
      readonly __typename: "RealtimePrice"
      readonly timestamp: number
      readonly denominatorCurrency: string
      readonly btcSatPrice: {
        readonly __typename: "PriceOfOneSatInMinorUnit"
        readonly base: number
        readonly offset: number
      }
      readonly usdCentPrice: {
        readonly __typename: "PriceOfOneUsdCentInMinorUnit"
        readonly base: number
        readonly offset: number
      }
    } | null
  }
}

export type RealtimePriceInitialQueryVariables = Exact<{
  currency: Scalars["DisplayCurrency"]
}>

export type RealtimePriceInitialQuery = {
  readonly __typename: "Query"
  readonly realtimePrice: {
    readonly __typename: "RealtimePrice"
    readonly timestamp: number
    readonly denominatorCurrency: string
    readonly btcSatPrice: {
      readonly __typename: "PriceOfOneSatInMinorUnit"
      readonly base: number
      readonly offset: number
    }
    readonly usdCentPrice: {
      readonly __typename: "PriceOfOneUsdCentInMinorUnit"
      readonly base: number
      readonly offset: number
    }
  }
}

export type PriceSubscriptionVariables = Exact<{
  amount: Scalars["SatAmount"]
  amountCurrencyUnit: ExchangeCurrencyUnit
  priceCurrencyUnit: ExchangeCurrencyUnit
}>

export type PriceSubscription = {
  readonly __typename: "Subscription"
  readonly price: {
    readonly __typename: "PricePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly price?: {
      readonly __typename: "Price"
      readonly base: number
      readonly offset: number
      readonly currencyUnit: string
      readonly formattedAmount: string
    } | null
  }
}

export type AccountDefaultWalletsQueryVariables = Exact<{
  username: Scalars["Username"]
}>

export type AccountDefaultWalletsQuery = {
  readonly __typename: "Query"
  readonly accountDefaultWallet: {
    readonly __typename: "PublicWallet"
    readonly id: string
    readonly walletCurrency: WalletCurrency
  }
}

export type AccountDefaultWalletQueryVariables = Exact<{
  username: Scalars["Username"]
  walletCurrency: WalletCurrency
}>

export type AccountDefaultWalletQuery = {
  readonly __typename: "Query"
  readonly accountDefaultWallet: {
    readonly __typename: "PublicWallet"
    readonly id: string
    readonly walletCurrency: WalletCurrency
  }
}

export type LnInvoiceCreateOnBehalfOfRecipientMutationVariables = Exact<{
  walletId: Scalars["WalletId"]
  amount: Scalars["SatAmount"]
  descriptionHash: Scalars["Hex32Bytes"]
}>

export type LnInvoiceCreateOnBehalfOfRecipientMutation = {
  readonly __typename: "Mutation"
  readonly mutationData: {
    readonly __typename: "LnInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnInvoice"
      readonly paymentRequest: string
      readonly paymentHash: string
    } | null
  }
}

export type NodeIdsQueryVariables = Exact<{ [key: string]: never }>

export type NodeIdsQuery = {
  readonly __typename: "Query"
  readonly globals?: {
    readonly __typename: "Globals"
    readonly nodesIds: ReadonlyArray<string>
  } | null
}

export type AccountDefaultWallet2QueryVariables = Exact<{
  username: Scalars["Username"]
}>

export type AccountDefaultWallet2Query = {
  readonly __typename: "Query"
  readonly accountDefaultWallet: {
    readonly __typename: "PublicWallet"
    readonly id: string
    readonly walletCurrency: WalletCurrency
  }
}

export const LnInvoicePaymentStatusDocument = gql`
  subscription lnInvoicePaymentStatus($input: LnInvoicePaymentStatusInput!) {
    lnInvoicePaymentStatus(input: $input) {
      __typename
      errors {
        message
        __typename
      }
      status
    }
  }
`

/**
 * __useLnInvoicePaymentStatusSubscription__
 *
 * To run a query within a React component, call `useLnInvoicePaymentStatusSubscription` and pass it any options that fit your needs.
 * When your component renders, `useLnInvoicePaymentStatusSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLnInvoicePaymentStatusSubscription({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoicePaymentStatusSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<
    LnInvoicePaymentStatusSubscription,
    LnInvoicePaymentStatusSubscriptionVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<
    LnInvoicePaymentStatusSubscription,
    LnInvoicePaymentStatusSubscriptionVariables
  >(LnInvoicePaymentStatusDocument, options)
}
export type LnInvoicePaymentStatusSubscriptionHookResult = ReturnType<
  typeof useLnInvoicePaymentStatusSubscription
>
export type LnInvoicePaymentStatusSubscriptionResult =
  Apollo.SubscriptionResult<LnInvoicePaymentStatusSubscription>
export const LnNoAmountInvoiceCreateOnBehalfOfRecipientDocument = gql`
  mutation lnNoAmountInvoiceCreateOnBehalfOfRecipient($walletId: WalletId!) {
    mutationData: lnNoAmountInvoiceCreateOnBehalfOfRecipient(
      input: { recipientWalletId: $walletId }
    ) {
      errors {
        message
      }
      invoice {
        paymentRequest
      }
    }
  }
`
export type LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationFn =
  Apollo.MutationFunction<
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation,
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationVariables
  >

/**
 * __useLnNoAmountInvoiceCreateOnBehalfOfRecipientMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoiceCreateOnBehalfOfRecipientMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoiceCreateOnBehalfOfRecipientMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoiceCreateOnBehalfOfRecipientMutation, { data, loading, error }] = useLnNoAmountInvoiceCreateOnBehalfOfRecipientMutation({
 *   variables: {
 *      walletId: // value for 'walletId'
 *   },
 * });
 */
export function useLnNoAmountInvoiceCreateOnBehalfOfRecipientMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation,
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation,
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationVariables
  >(LnNoAmountInvoiceCreateOnBehalfOfRecipientDocument, options)
}
export type LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationHookResult = ReturnType<
  typeof useLnNoAmountInvoiceCreateOnBehalfOfRecipientMutation
>
export type LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationResult =
  Apollo.MutationResult<LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation>
export type LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationOptions =
  Apollo.BaseMutationOptions<
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutation,
    LnNoAmountInvoiceCreateOnBehalfOfRecipientMutationVariables
  >
export const LnUsdInvoiceCreateOnBehalfOfRecipientDocument = gql`
  mutation lnUsdInvoiceCreateOnBehalfOfRecipient(
    $input: LnUsdInvoiceCreateOnBehalfOfRecipientInput!
  ) {
    lnUsdInvoiceCreateOnBehalfOfRecipient(input: $input) {
      errors {
        __typename
        message
      }
      invoice {
        __typename
        paymentHash
        paymentRequest
        paymentSecret
        satoshis
      }
      __typename
    }
  }
`
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationFn = Apollo.MutationFunction<
  LnUsdInvoiceCreateOnBehalfOfRecipientMutation,
  LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables
>

/**
 * __useLnUsdInvoiceCreateOnBehalfOfRecipientMutation__
 *
 * To run a mutation, you first call `useLnUsdInvoiceCreateOnBehalfOfRecipientMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnUsdInvoiceCreateOnBehalfOfRecipientMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnUsdInvoiceCreateOnBehalfOfRecipientMutation, { data, loading, error }] = useLnUsdInvoiceCreateOnBehalfOfRecipientMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnUsdInvoiceCreateOnBehalfOfRecipientMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnUsdInvoiceCreateOnBehalfOfRecipientMutation,
    LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnUsdInvoiceCreateOnBehalfOfRecipientMutation,
    LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables
  >(LnUsdInvoiceCreateOnBehalfOfRecipientDocument, options)
}
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationHookResult = ReturnType<
  typeof useLnUsdInvoiceCreateOnBehalfOfRecipientMutation
>
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationResult =
  Apollo.MutationResult<LnUsdInvoiceCreateOnBehalfOfRecipientMutation>
export type LnUsdInvoiceCreateOnBehalfOfRecipientMutationOptions =
  Apollo.BaseMutationOptions<
    LnUsdInvoiceCreateOnBehalfOfRecipientMutation,
    LnUsdInvoiceCreateOnBehalfOfRecipientMutationVariables
  >
export const LnInvoiceCreateOnBehalfOfRecipientsDocument = gql`
  mutation lnInvoiceCreateOnBehalfOfRecipients(
    $input: LnInvoiceCreateOnBehalfOfRecipientInput!
  ) {
    lnInvoiceCreateOnBehalfOfRecipient(input: $input) {
      errors {
        __typename
        message
      }
      invoice {
        __typename
        paymentHash
        paymentRequest
        paymentSecret
        satoshis
      }
      __typename
    }
  }
`
export type LnInvoiceCreateOnBehalfOfRecipientsMutationFn = Apollo.MutationFunction<
  LnInvoiceCreateOnBehalfOfRecipientsMutation,
  LnInvoiceCreateOnBehalfOfRecipientsMutationVariables
>

/**
 * __useLnInvoiceCreateOnBehalfOfRecipientsMutation__
 *
 * To run a mutation, you first call `useLnInvoiceCreateOnBehalfOfRecipientsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceCreateOnBehalfOfRecipientsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceCreateOnBehalfOfRecipientsMutation, { data, loading, error }] = useLnInvoiceCreateOnBehalfOfRecipientsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoiceCreateOnBehalfOfRecipientsMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnInvoiceCreateOnBehalfOfRecipientsMutation,
    LnInvoiceCreateOnBehalfOfRecipientsMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnInvoiceCreateOnBehalfOfRecipientsMutation,
    LnInvoiceCreateOnBehalfOfRecipientsMutationVariables
  >(LnInvoiceCreateOnBehalfOfRecipientsDocument, options)
}
export type LnInvoiceCreateOnBehalfOfRecipientsMutationHookResult = ReturnType<
  typeof useLnInvoiceCreateOnBehalfOfRecipientsMutation
>
export type LnInvoiceCreateOnBehalfOfRecipientsMutationResult =
  Apollo.MutationResult<LnInvoiceCreateOnBehalfOfRecipientsMutation>
export type LnInvoiceCreateOnBehalfOfRecipientsMutationOptions =
  Apollo.BaseMutationOptions<
    LnInvoiceCreateOnBehalfOfRecipientsMutation,
    LnInvoiceCreateOnBehalfOfRecipientsMutationVariables
  >
export const CurrencyListDocument = gql`
  query currencyList {
    currencyList {
      __typename
      id
      flag
      name
      symbol
      fractionDigits
    }
  }
`

/**
 * __useCurrencyListQuery__
 *
 * To run a query within a React component, call `useCurrencyListQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrencyListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrencyListQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrencyListQuery(
  baseOptions?: Apollo.QueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CurrencyListQuery, CurrencyListQueryVariables>(
    CurrencyListDocument,
    options,
  )
}
export function useCurrencyListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    CurrencyListQuery,
    CurrencyListQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CurrencyListQuery, CurrencyListQueryVariables>(
    CurrencyListDocument,
    options,
  )
}
export type CurrencyListQueryHookResult = ReturnType<typeof useCurrencyListQuery>
export type CurrencyListLazyQueryHookResult = ReturnType<typeof useCurrencyListLazyQuery>
export type CurrencyListQueryResult = Apollo.QueryResult<
  CurrencyListQuery,
  CurrencyListQueryVariables
>
export const RealtimePriceWsDocument = gql`
  subscription realtimePriceWs($currency: DisplayCurrency!) {
    realtimePrice(input: { currency: $currency }) {
      errors {
        message
      }
      realtimePrice {
        timestamp
        btcSatPrice {
          base
          offset
        }
        usdCentPrice {
          base
          offset
        }
        denominatorCurrency
      }
    }
  }
`

/**
 * __useRealtimePriceWsSubscription__
 *
 * To run a query within a React component, call `useRealtimePriceWsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useRealtimePriceWsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRealtimePriceWsSubscription({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useRealtimePriceWsSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<
    RealtimePriceWsSubscription,
    RealtimePriceWsSubscriptionVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<
    RealtimePriceWsSubscription,
    RealtimePriceWsSubscriptionVariables
  >(RealtimePriceWsDocument, options)
}
export type RealtimePriceWsSubscriptionHookResult = ReturnType<
  typeof useRealtimePriceWsSubscription
>
export type RealtimePriceWsSubscriptionResult =
  Apollo.SubscriptionResult<RealtimePriceWsSubscription>
export const RealtimePriceInitialDocument = gql`
  query realtimePriceInitial($currency: DisplayCurrency!) {
    realtimePrice(currency: $currency) {
      timestamp
      btcSatPrice {
        base
        offset
      }
      usdCentPrice {
        base
        offset
      }
      denominatorCurrency
    }
  }
`

/**
 * __useRealtimePriceInitialQuery__
 *
 * To run a query within a React component, call `useRealtimePriceInitialQuery` and pass it any options that fit your needs.
 * When your component renders, `useRealtimePriceInitialQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRealtimePriceInitialQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useRealtimePriceInitialQuery(
  baseOptions: Apollo.QueryHookOptions<
    RealtimePriceInitialQuery,
    RealtimePriceInitialQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RealtimePriceInitialQuery, RealtimePriceInitialQueryVariables>(
    RealtimePriceInitialDocument,
    options,
  )
}
export function useRealtimePriceInitialLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RealtimePriceInitialQuery,
    RealtimePriceInitialQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RealtimePriceInitialQuery,
    RealtimePriceInitialQueryVariables
  >(RealtimePriceInitialDocument, options)
}
export type RealtimePriceInitialQueryHookResult = ReturnType<
  typeof useRealtimePriceInitialQuery
>
export type RealtimePriceInitialLazyQueryHookResult = ReturnType<
  typeof useRealtimePriceInitialLazyQuery
>
export type RealtimePriceInitialQueryResult = Apollo.QueryResult<
  RealtimePriceInitialQuery,
  RealtimePriceInitialQueryVariables
>
export const PriceDocument = gql`
  subscription price(
    $amount: SatAmount!
    $amountCurrencyUnit: ExchangeCurrencyUnit!
    $priceCurrencyUnit: ExchangeCurrencyUnit!
  ) {
    price(
      input: {
        amount: $amount
        amountCurrencyUnit: $amountCurrencyUnit
        priceCurrencyUnit: $priceCurrencyUnit
      }
    ) {
      errors {
        message
      }
      price {
        base
        offset
        currencyUnit
        formattedAmount
      }
    }
  }
`

/**
 * __usePriceSubscription__
 *
 * To run a query within a React component, call `usePriceSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePriceSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePriceSubscription({
 *   variables: {
 *      amount: // value for 'amount'
 *      amountCurrencyUnit: // value for 'amountCurrencyUnit'
 *      priceCurrencyUnit: // value for 'priceCurrencyUnit'
 *   },
 * });
 */
export function usePriceSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<
    PriceSubscription,
    PriceSubscriptionVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<PriceSubscription, PriceSubscriptionVariables>(
    PriceDocument,
    options,
  )
}
export type PriceSubscriptionHookResult = ReturnType<typeof usePriceSubscription>
export type PriceSubscriptionResult = Apollo.SubscriptionResult<PriceSubscription>
export const AccountDefaultWalletsDocument = gql`
  query accountDefaultWallets($username: Username!) {
    accountDefaultWallet(username: $username) {
      __typename
      id
      walletCurrency
    }
  }
`

/**
 * __useAccountDefaultWalletsQuery__
 *
 * To run a query within a React component, call `useAccountDefaultWalletsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWalletsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWalletsQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useAccountDefaultWalletsQuery(
  baseOptions: Apollo.QueryHookOptions<
    AccountDefaultWalletsQuery,
    AccountDefaultWalletsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AccountDefaultWalletsQuery, AccountDefaultWalletsQueryVariables>(
    AccountDefaultWalletsDocument,
    options,
  )
}
export function useAccountDefaultWalletsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AccountDefaultWalletsQuery,
    AccountDefaultWalletsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    AccountDefaultWalletsQuery,
    AccountDefaultWalletsQueryVariables
  >(AccountDefaultWalletsDocument, options)
}
export type AccountDefaultWalletsQueryHookResult = ReturnType<
  typeof useAccountDefaultWalletsQuery
>
export type AccountDefaultWalletsLazyQueryHookResult = ReturnType<
  typeof useAccountDefaultWalletsLazyQuery
>
export type AccountDefaultWalletsQueryResult = Apollo.QueryResult<
  AccountDefaultWalletsQuery,
  AccountDefaultWalletsQueryVariables
>
export const AccountDefaultWalletDocument = gql`
  query accountDefaultWallet($username: Username!, $walletCurrency: WalletCurrency!) {
    accountDefaultWallet(username: $username, walletCurrency: $walletCurrency) {
      __typename
      id
      walletCurrency
    }
  }
`

/**
 * __useAccountDefaultWalletQuery__
 *
 * To run a query within a React component, call `useAccountDefaultWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWalletQuery({
 *   variables: {
 *      username: // value for 'username'
 *      walletCurrency: // value for 'walletCurrency'
 *   },
 * });
 */
export function useAccountDefaultWalletQuery(
  baseOptions: Apollo.QueryHookOptions<
    AccountDefaultWalletQuery,
    AccountDefaultWalletQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(
    AccountDefaultWalletDocument,
    options,
  )
}
export function useAccountDefaultWalletLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AccountDefaultWalletQuery,
    AccountDefaultWalletQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    AccountDefaultWalletQuery,
    AccountDefaultWalletQueryVariables
  >(AccountDefaultWalletDocument, options)
}
export type AccountDefaultWalletQueryHookResult = ReturnType<
  typeof useAccountDefaultWalletQuery
>
export type AccountDefaultWalletLazyQueryHookResult = ReturnType<
  typeof useAccountDefaultWalletLazyQuery
>
export type AccountDefaultWalletQueryResult = Apollo.QueryResult<
  AccountDefaultWalletQuery,
  AccountDefaultWalletQueryVariables
>
export const LnInvoiceCreateOnBehalfOfRecipientDocument = gql`
  mutation lnInvoiceCreateOnBehalfOfRecipient(
    $walletId: WalletId!
    $amount: SatAmount!
    $descriptionHash: Hex32Bytes!
  ) {
    mutationData: lnInvoiceCreateOnBehalfOfRecipient(
      input: {
        recipientWalletId: $walletId
        amount: $amount
        descriptionHash: $descriptionHash
      }
    ) {
      errors {
        message
      }
      invoice {
        paymentRequest
        paymentHash
      }
    }
  }
`
export type LnInvoiceCreateOnBehalfOfRecipientMutationFn = Apollo.MutationFunction<
  LnInvoiceCreateOnBehalfOfRecipientMutation,
  LnInvoiceCreateOnBehalfOfRecipientMutationVariables
>

/**
 * __useLnInvoiceCreateOnBehalfOfRecipientMutation__
 *
 * To run a mutation, you first call `useLnInvoiceCreateOnBehalfOfRecipientMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceCreateOnBehalfOfRecipientMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceCreateOnBehalfOfRecipientMutation, { data, loading, error }] = useLnInvoiceCreateOnBehalfOfRecipientMutation({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      amount: // value for 'amount'
 *      descriptionHash: // value for 'descriptionHash'
 *   },
 * });
 */
export function useLnInvoiceCreateOnBehalfOfRecipientMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnInvoiceCreateOnBehalfOfRecipientMutation,
    LnInvoiceCreateOnBehalfOfRecipientMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnInvoiceCreateOnBehalfOfRecipientMutation,
    LnInvoiceCreateOnBehalfOfRecipientMutationVariables
  >(LnInvoiceCreateOnBehalfOfRecipientDocument, options)
}
export type LnInvoiceCreateOnBehalfOfRecipientMutationHookResult = ReturnType<
  typeof useLnInvoiceCreateOnBehalfOfRecipientMutation
>
export type LnInvoiceCreateOnBehalfOfRecipientMutationResult =
  Apollo.MutationResult<LnInvoiceCreateOnBehalfOfRecipientMutation>
export type LnInvoiceCreateOnBehalfOfRecipientMutationOptions =
  Apollo.BaseMutationOptions<
    LnInvoiceCreateOnBehalfOfRecipientMutation,
    LnInvoiceCreateOnBehalfOfRecipientMutationVariables
  >
export const NodeIdsDocument = gql`
  query nodeIds {
    globals {
      nodesIds
    }
  }
`

/**
 * __useNodeIdsQuery__
 *
 * To run a query within a React component, call `useNodeIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNodeIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNodeIdsQuery({
 *   variables: {
 *   },
 * });
 */
export function useNodeIdsQuery(
  baseOptions?: Apollo.QueryHookOptions<NodeIdsQuery, NodeIdsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<NodeIdsQuery, NodeIdsQueryVariables>(NodeIdsDocument, options)
}
export function useNodeIdsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NodeIdsQuery, NodeIdsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<NodeIdsQuery, NodeIdsQueryVariables>(
    NodeIdsDocument,
    options,
  )
}
export type NodeIdsQueryHookResult = ReturnType<typeof useNodeIdsQuery>
export type NodeIdsLazyQueryHookResult = ReturnType<typeof useNodeIdsLazyQuery>
export type NodeIdsQueryResult = Apollo.QueryResult<NodeIdsQuery, NodeIdsQueryVariables>
export const AccountDefaultWallet2Document = gql`
  query accountDefaultWallet2($username: Username!) {
    accountDefaultWallet(username: $username) {
      id
      walletCurrency
    }
  }
`

/**
 * __useAccountDefaultWallet2Query__
 *
 * To run a query within a React component, call `useAccountDefaultWallet2Query` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWallet2Query` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWallet2Query({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useAccountDefaultWallet2Query(
  baseOptions: Apollo.QueryHookOptions<
    AccountDefaultWallet2Query,
    AccountDefaultWallet2QueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AccountDefaultWallet2Query, AccountDefaultWallet2QueryVariables>(
    AccountDefaultWallet2Document,
    options,
  )
}
export function useAccountDefaultWallet2LazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AccountDefaultWallet2Query,
    AccountDefaultWallet2QueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    AccountDefaultWallet2Query,
    AccountDefaultWallet2QueryVariables
  >(AccountDefaultWallet2Document, options)
}
export type AccountDefaultWallet2QueryHookResult = ReturnType<
  typeof useAccountDefaultWallet2Query
>
export type AccountDefaultWallet2LazyQueryHookResult = ReturnType<
  typeof useAccountDefaultWallet2LazyQuery
>
export type AccountDefaultWallet2QueryResult = Apollo.QueryResult<
  AccountDefaultWallet2Query,
  AccountDefaultWallet2QueryVariables
>
